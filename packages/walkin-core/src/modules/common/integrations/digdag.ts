/**
 * Digdag
 * Digdag server API
 *
 * OpenAPI spec version: 0.9.39
 *
 * Thejesh GN
 *
 * NOTE: The Swagger generated by the DigDag doesn't have the authorization as the
 * auth infact is not given by the digdag but by NGINX.
 * So I modified the swagger yaml to include basic auth and then generated this code.
 * Copy is here for your reference -> https://gitlab.com/WalkIn/analytics/walkin-etl-monorepo/snippets/1894295
 *
 * So make sure to use that as base when you want to regenrate the swagger API client again
 *
 * This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */

import localVarRequest = require("request");
import http = require("http");
import Promise = require("bluebird");

let defaultBasePath = "https://localhost";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any"
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (const d of data) {
        let date = d;
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (const attributeType of attributeTypes) {
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (const d of data) {
        let date = d;
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (const attributeType of attributeTypes) {
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

export class Attempt {
  "retryAttemptName"?: string;
  "params"?: Config;
  "createdAt"?: number;
  "finishedAt"?: number;
  "success"?: boolean;
  "done"?: boolean;
  "cancelRequested"?: boolean;
  "id"?: Id;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "retryAttemptName",
      baseName: "retryAttemptName",
      type: "string"
    },
    {
      name: "params",
      baseName: "params",
      type: "Config"
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number"
    },
    {
      name: "finishedAt",
      baseName: "finishedAt",
      type: "number"
    },
    {
      name: "success",
      baseName: "success",
      type: "boolean"
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean"
    },
    {
      name: "cancelRequested",
      baseName: "cancelRequested",
      type: "boolean"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  static getAttributeTypeMap() {
    return Attempt.attributeTypeMap;
  }
}

// tslint:disable-next-line:max-classes-per-file
export class Config {
  "empty"?: boolean;
  "factory"?: ConfigFactory;
  "keys"?: Array<string>;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "empty",
      baseName: "empty",
      type: "boolean"
    },
    {
      name: "factory",
      baseName: "factory",
      type: "ConfigFactory"
    },
    {
      name: "keys",
      baseName: "keys",
      type: "Array<string>"
    }
  ];

  public static getAttributeTypeMap() {
    return Config.attributeTypeMap;
  }
}

export class ConfigFactory {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return ConfigFactory.attributeTypeMap;
  }
}

export class DirectUploadHandle {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return DirectUploadHandle.attributeTypeMap;
  }
}

export class Duration {
  "seconds"?: number;
  "zero"?: boolean;
  "negative"?: boolean;
  "nano"?: number;
  "units"?: Array<TemporalUnit>;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "seconds",
      baseName: "seconds",
      type: "number"
    },
    {
      name: "zero",
      baseName: "zero",
      type: "boolean"
    },
    {
      name: "negative",
      baseName: "negative",
      type: "boolean"
    },
    {
      name: "nano",
      baseName: "nano",
      type: "number"
    },
    {
      name: "units",
      baseName: "units",
      type: "Array<TemporalUnit>"
    }
  ];

  public static getAttributeTypeMap() {
    return Duration.attributeTypeMap;
  }
}

export class Id {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return Id.attributeTypeMap;
  }
}

export class IdAndName {
  "name"?: string;
  "id"?: Id;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  public static getAttributeTypeMap() {
    return IdAndName.attributeTypeMap;
  }
}

export class InputStream {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return InputStream.attributeTypeMap;
  }
}

export class LocalTime {
  "hour"?: number;
  "minute"?: number;
  "second"?: number;
  "nano"?: number;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "hour",
      baseName: "hour",
      type: "number"
    },
    {
      name: "minute",
      baseName: "minute",
      type: "number"
    },
    {
      name: "second",
      baseName: "second",
      type: "number"
    },
    {
      name: "nano",
      baseName: "nano",
      type: "number"
    }
  ];

  public static getAttributeTypeMap() {
    return LocalTime.attributeTypeMap;
  }
}

export class LocalTimeOrInstant {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return LocalTimeOrInstant.attributeTypeMap;
  }
}

export class NameOptionalId {
  "name"?: string;
  "id"?: Id;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  public static getAttributeTypeMap() {
    return NameOptionalId.attributeTypeMap;
  }
}

export class OffsetDateTime {
  "offset"?: ZoneOffset;
  "monthValue"?: number;
  "dayOfYear"?: number;
  "dayOfWeek"?: OffsetDateTime.DayOfWeekEnum;
  "month"?: OffsetDateTime.MonthEnum;
  "dayOfMonth"?: number;
  "year"?: number;
  "hour"?: number;
  "minute"?: number;
  "nano"?: number;
  "second"?: number;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "offset",
      baseName: "offset",
      type: "ZoneOffset"
    },
    {
      name: "monthValue",
      baseName: "monthValue",
      type: "number"
    },
    {
      name: "dayOfYear",
      baseName: "dayOfYear",
      type: "number"
    },
    {
      name: "dayOfWeek",
      baseName: "dayOfWeek",
      type: "OffsetDateTime.DayOfWeekEnum"
    },
    {
      name: "month",
      baseName: "month",
      type: "OffsetDateTime.MonthEnum"
    },
    {
      name: "dayOfMonth",
      baseName: "dayOfMonth",
      type: "number"
    },
    {
      name: "year",
      baseName: "year",
      type: "number"
    },
    {
      name: "hour",
      baseName: "hour",
      type: "number"
    },
    {
      name: "minute",
      baseName: "minute",
      type: "number"
    },
    {
      name: "nano",
      baseName: "nano",
      type: "number"
    },
    {
      name: "second",
      baseName: "second",
      type: "number"
    }
  ];

  public static getAttributeTypeMap() {
    return OffsetDateTime.attributeTypeMap;
  }
}

export namespace OffsetDateTime {
  export enum DayOfWeekEnum {
    MONDAY = <any>"MONDAY",
    TUESDAY = <any>"TUESDAY",
    WEDNESDAY = <any>"WEDNESDAY",
    THURSDAY = <any>"THURSDAY",
    FRIDAY = <any>"FRIDAY",
    SATURDAY = <any>"SATURDAY",
    SUNDAY = <any>"SUNDAY"
  }
  export enum MonthEnum {
    JANUARY = <any>"JANUARY",
    FEBRUARY = <any>"FEBRUARY",
    MARCH = <any>"MARCH",
    APRIL = <any>"APRIL",
    MAY = <any>"MAY",
    JUNE = <any>"JUNE",
    JULY = <any>"JULY",
    AUGUST = <any>"AUGUST",
    SEPTEMBER = <any>"SEPTEMBER",
    OCTOBER = <any>"OCTOBER",
    NOVEMBER = <any>"NOVEMBER",
    DECEMBER = <any>"DECEMBER"
  }
}
export class RestDirectDownloadHandle {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return RestDirectDownloadHandle.attributeTypeMap;
  }
}

export class RestLogFileHandle {
  "taskName"?: string;
  "direct"?: RestDirectDownloadHandle;
  "fileTime"?: number;
  "agentId"?: string;
  "fileSize"?: number;
  "fileName"?: string;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "taskName",
      baseName: "taskName",
      type: "string"
    },
    {
      name: "direct",
      baseName: "direct",
      type: "RestDirectDownloadHandle"
    },
    {
      name: "fileTime",
      baseName: "fileTime",
      type: "number"
    },
    {
      name: "agentId",
      baseName: "agentId",
      type: "string"
    },
    {
      name: "fileSize",
      baseName: "fileSize",
      type: "number"
    },
    {
      name: "fileName",
      baseName: "fileName",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return RestLogFileHandle.attributeTypeMap;
  }
}

export class RestLogFileHandleCollection {
  "files"?: Array<RestLogFileHandle>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "files",
      baseName: "files",
      type: "Array<RestLogFileHandle>"
    }
  ];

  static getAttributeTypeMap() {
    return RestLogFileHandleCollection.attributeTypeMap;
  }
}

export class RestLogFilePutResult {
  "fileName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "fileName",
      baseName: "fileName",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return RestLogFilePutResult.attributeTypeMap;
  }
}

export class RestProject {
  "revision"?: string;
  "createdAt"?: number;
  "archiveType"?: string;
  "archiveMd5"?: Array<string>;
  "deletedAt"?: number;
  "updatedAt"?: number;
  "name"?: string;
  "id"?: Id;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "revision",
      baseName: "revision",
      type: "string"
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number"
    },
    {
      name: "archiveType",
      baseName: "archiveType",
      type: "string"
    },
    {
      name: "archiveMd5",
      baseName: "archiveMd5",
      type: "Array<string>"
    },
    {
      name: "deletedAt",
      baseName: "deletedAt",
      type: "number"
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "number"
    },
    {
      name: "name",
      baseName: "name",
      type: "string"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  static getAttributeTypeMap() {
    return RestProject.attributeTypeMap;
  }
}

export class RestProjectCollection {
  "projects"?: Array<RestProject>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "projects",
      baseName: "projects",
      type: "Array<RestProject>"
    }
  ];

  static getAttributeTypeMap() {
    return RestProjectCollection.attributeTypeMap;
  }
}

export class RestRevision {
  "revision"?: string;
  "createdAt"?: number;
  "archiveType"?: string;
  "archiveMd5"?: Array<string>;
  "userInfo"?: Config;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "revision",
      baseName: "revision",
      type: "string"
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number"
    },
    {
      name: "archiveType",
      baseName: "archiveType",
      type: "string"
    },
    {
      name: "archiveMd5",
      baseName: "archiveMd5",
      type: "Array<string>"
    },
    {
      name: "userInfo",
      baseName: "userInfo",
      type: "Config"
    }
  ];

  static getAttributeTypeMap() {
    return RestRevision.attributeTypeMap;
  }
}

export class RestRevisionCollection {
  "revisions"?: Array<RestRevision>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "revisions",
      baseName: "revisions",
      type: "Array<RestRevision>"
    }
  ];

  static getAttributeTypeMap() {
    return RestRevisionCollection.attributeTypeMap;
  }
}

export class RestSchedule {
  "project"?: IdAndName;
  "workflow"?: IdAndName;
  "disabledAt"?: number;
  "nextScheduleTime"?: OffsetDateTime;
  "nextRunTime"?: number;
  "id"?: Id;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "project",
      baseName: "project",
      type: "IdAndName"
    },
    {
      name: "workflow",
      baseName: "workflow",
      type: "IdAndName"
    },
    {
      name: "disabledAt",
      baseName: "disabledAt",
      type: "number"
    },
    {
      name: "nextScheduleTime",
      baseName: "nextScheduleTime",
      type: "OffsetDateTime"
    },
    {
      name: "nextRunTime",
      baseName: "nextRunTime",
      type: "number"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  static getAttributeTypeMap() {
    return RestSchedule.attributeTypeMap;
  }
}

export class RestScheduleBackfillRequest {
  "count"?: number;
  "fromTime"?: number;
  "attemptName"?: string;
  "dryRun"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number"
    },
    {
      name: "fromTime",
      baseName: "fromTime",
      type: "number"
    },
    {
      name: "attemptName",
      baseName: "attemptName",
      type: "string"
    },
    {
      name: "dryRun",
      baseName: "dryRun",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return RestScheduleBackfillRequest.attributeTypeMap;
  }
}

export class RestScheduleCollection {
  "schedules"?: Array<RestSchedule>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "schedules",
      baseName: "schedules",
      type: "Array<RestSchedule>"
    }
  ];

  static getAttributeTypeMap() {
    return RestScheduleCollection.attributeTypeMap;
  }
}

export class RestScheduleSkipRequest {
  "count"?: number;
  "nextRunTime"?: number;
  "fromTime"?: number;
  "dryRun"?: boolean;
  "nextTime"?: LocalTimeOrInstant;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number"
    },
    {
      name: "nextRunTime",
      baseName: "nextRunTime",
      type: "number"
    },
    {
      name: "fromTime",
      baseName: "fromTime",
      type: "number"
    },
    {
      name: "dryRun",
      baseName: "dryRun",
      type: "boolean"
    },
    {
      name: "nextTime",
      baseName: "nextTime",
      type: "LocalTimeOrInstant"
    }
  ];

  static getAttributeTypeMap() {
    return RestScheduleSkipRequest.attributeTypeMap;
  }
}

export class RestScheduleSummary {
  "createdAt"?: number;
  "updatedAt"?: number;
  "workflow"?: IdAndName;
  "disabledAt"?: number;
  "nextScheduleTime"?: OffsetDateTime;
  "nextRunTime"?: number;
  "id"?: Id;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number"
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "number"
    },
    {
      name: "workflow",
      baseName: "workflow",
      type: "IdAndName"
    },
    {
      name: "disabledAt",
      baseName: "disabledAt",
      type: "number"
    },
    {
      name: "nextScheduleTime",
      baseName: "nextScheduleTime",
      type: "OffsetDateTime"
    },
    {
      name: "nextRunTime",
      baseName: "nextRunTime",
      type: "number"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  static getAttributeTypeMap() {
    return RestScheduleSummary.attributeTypeMap;
  }
}

export class RestSecretList {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return RestSecretList.attributeTypeMap;
  }
}

export class RestSession {
  "sessionUuid"?: string;
  "project"?: IdAndName;
  "sessionTime"?: OffsetDateTime;
  "lastAttempt"?: Attempt;
  "workflow"?: NameOptionalId;
  "id"?: Id;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sessionUuid",
      baseName: "sessionUuid",
      type: "string"
    },
    {
      name: "project",
      baseName: "project",
      type: "IdAndName"
    },
    {
      name: "sessionTime",
      baseName: "sessionTime",
      type: "OffsetDateTime"
    },
    {
      name: "lastAttempt",
      baseName: "lastAttempt",
      type: "Attempt"
    },
    {
      name: "workflow",
      baseName: "workflow",
      type: "NameOptionalId"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  public static getAttributeTypeMap() {
    return RestSession.attributeTypeMap;
  }
}

export class RestSessionAttempt {
  "index"?: number;
  "sessionUuid"?: string;
  "retryAttemptName"?: string;
  "params"?: Config;
  "sessionId"?: Id;
  "createdAt"?: number;
  "finishedAt"?: number;
  "project"?: IdAndName;
  "sessionTime"?: OffsetDateTime;
  "success"?: boolean;
  "done"?: boolean;
  "workflow"?: NameOptionalId;
  "cancelRequested"?: boolean;
  "id"?: Id;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "index",
      baseName: "index",
      type: "number"
    },
    {
      name: "sessionUuid",
      baseName: "sessionUuid",
      type: "string"
    },
    {
      name: "retryAttemptName",
      baseName: "retryAttemptName",
      type: "string"
    },
    {
      name: "params",
      baseName: "params",
      type: "Config"
    },
    {
      name: "sessionId",
      baseName: "sessionId",
      type: "Id"
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number"
    },
    {
      name: "finishedAt",
      baseName: "finishedAt",
      type: "number"
    },
    {
      name: "project",
      baseName: "project",
      type: "IdAndName"
    },
    {
      name: "sessionTime",
      baseName: "sessionTime",
      type: "OffsetDateTime"
    },
    {
      name: "success",
      baseName: "success",
      type: "boolean"
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean"
    },
    {
      name: "workflow",
      baseName: "workflow",
      type: "NameOptionalId"
    },
    {
      name: "cancelRequested",
      baseName: "cancelRequested",
      type: "boolean"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    }
  ];

  public static getAttributeTypeMap() {
    return RestSessionAttempt.attributeTypeMap;
  }
}

export class RestSessionAttemptCollection {
  "attempts"?: Array<RestSessionAttempt>;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "attempts",
      baseName: "attempts",
      type: "Array<RestSessionAttempt>"
    }
  ];

  public static getAttributeTypeMap() {
    return RestSessionAttemptCollection.attributeTypeMap;
  }
}

export class RestSessionAttemptRequest {
  "retryAttemptName"?: string;
  "params"?: any;
  "sessionTime"?: string;
  "workflowId"?: number;
  "resume"?: Resume;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "retryAttemptName",
      baseName: "retryAttemptName",
      type: "string"
    },
    {
      name: "params",
      baseName: "params",
      type: "Array"
    },
    {
      name: "sessionTime",
      baseName: "sessionTime",
      type: "string"
    },
    {
      name: "workflowId",
      baseName: "workflowId",
      type: "number"
    },
    {
      name: "resume",
      baseName: "resume",
      type: "Resume"
    }
  ];

  public static getAttributeTypeMap() {
    return RestSessionAttemptRequest.attributeTypeMap;
  }
}

export class RestSessionCollection {
  "sessions"?: Array<RestSession>;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sessions",
      baseName: "sessions",
      type: "Array<RestSession>"
    }
  ];

  public static getAttributeTypeMap() {
    return RestSessionCollection.attributeTypeMap;
  }
}

export class RestSetSecretRequest {
  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  public static getAttributeTypeMap() {
    return RestSetSecretRequest.attributeTypeMap;
  }
}

export class RestTask {
  "fullName"?: string;
  "parentId"?: Id;
  "upstreams"?: Array<Id>;
  "retryAt"?: number;
  "config"?: Config;
  "exportParams"?: Config;
  "storeParams"?: Config;
  "stateParams"?: Config;
  "error"?: Config;
  "updatedAt"?: number;
  "cancelRequested"?: boolean;
  "startedAt"?: number;
  "group"?: boolean;
  "id"?: Id;
  "state"?: string;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "fullName",
      baseName: "fullName",
      type: "string"
    },
    {
      name: "parentId",
      baseName: "parentId",
      type: "Id"
    },
    {
      name: "upstreams",
      baseName: "upstreams",
      type: "Array<Id>"
    },
    {
      name: "retryAt",
      baseName: "retryAt",
      type: "number"
    },
    {
      name: "config",
      baseName: "config",
      type: "Config"
    },
    {
      name: "exportParams",
      baseName: "exportParams",
      type: "Config"
    },
    {
      name: "storeParams",
      baseName: "storeParams",
      type: "Config"
    },
    {
      name: "stateParams",
      baseName: "stateParams",
      type: "Config"
    },
    {
      name: "error",
      baseName: "error",
      type: "Config"
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "number"
    },
    {
      name: "cancelRequested",
      baseName: "cancelRequested",
      type: "boolean"
    },
    {
      name: "startedAt",
      baseName: "startedAt",
      type: "number"
    },
    {
      name: "group",
      baseName: "group",
      type: "boolean"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    },
    {
      name: "state",
      baseName: "state",
      type: "string"
    }
  ];

  public static getAttributeTypeMap() {
    return RestTask.attributeTypeMap;
  }
}

export class RestTaskCollection {
  "tasks"?: Array<RestTask>;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "tasks",
      baseName: "tasks",
      type: "Array<RestTask>"
    }
  ];

  public static getAttributeTypeMap() {
    return RestTaskCollection.attributeTypeMap;
  }
}

export class RestVersionCheckResult {
  "apiCompatible"?: boolean;
  "serverVersion"?: string;
  "upgradeRecommended"?: boolean;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "apiCompatible",
      baseName: "apiCompatible",
      type: "boolean"
    },
    {
      name: "serverVersion",
      baseName: "serverVersion",
      type: "string"
    },
    {
      name: "upgradeRecommended",
      baseName: "upgradeRecommended",
      type: "boolean"
    }
  ];

  public static getAttributeTypeMap() {
    return RestVersionCheckResult.attributeTypeMap;
  }
}

export class RestWorkflowDefinition {
  "config"?: Config;
  "revision"?: string;
  "project"?: IdAndName;
  "name"?: string;
  "id"?: Id;
  "timezone"?: ZoneId;

  public static discriminator: string | undefined = undefined;

  public static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "config",
      baseName: "config",
      type: "Config"
    },
    {
      name: "revision",
      baseName: "revision",
      type: "string"
    },
    {
      name: "project",
      baseName: "project",
      type: "IdAndName"
    },
    {
      name: "name",
      baseName: "name",
      type: "string"
    },
    {
      name: "id",
      baseName: "id",
      type: "Id"
    },
    {
      name: "timezone",
      baseName: "timezone",
      type: "ZoneId"
    }
  ];

  static getAttributeTypeMap() {
    return RestWorkflowDefinition.attributeTypeMap;
  }
}

export class RestWorkflowDefinitionCollection {
  "workflows"?: Array<RestWorkflowDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "workflows",
      baseName: "workflows",
      type: "Array<RestWorkflowDefinition>"
    }
  ];

  static getAttributeTypeMap() {
    return RestWorkflowDefinitionCollection.attributeTypeMap;
  }
}

export class RestWorkflowSessionTime {
  "revision"?: string;
  "project"?: IdAndName;
  "sessionTime"?: OffsetDateTime;
  "timezone"?: ZoneId;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "revision",
      baseName: "revision",
      type: "string"
    },
    {
      name: "project",
      baseName: "project",
      type: "IdAndName"
    },
    {
      name: "sessionTime",
      baseName: "sessionTime",
      type: "OffsetDateTime"
    },
    {
      name: "timezone",
      baseName: "timezone",
      type: "ZoneId"
    }
  ];

  static getAttributeTypeMap() {
    return RestWorkflowSessionTime.attributeTypeMap;
  }
}

export class Resume {
  "attemptId"?: Id;
  "mode"?: Resume.ModeEnum;

  static discriminator: string | undefined = "mode";

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "attemptId",
      baseName: "attemptId",
      type: "Id"
    },
    {
      name: "mode",
      baseName: "mode",
      type: "Resume.ModeEnum"
    }
  ];

  static getAttributeTypeMap() {
    return Resume.attributeTypeMap;
  }
}

export namespace Resume {
  export enum ModeEnum {
    FROM = <any>"FROM",
    FAILED = <any>"FAILED"
  }
}
export class ResumeFailed extends Resume {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(ResumeFailed.attributeTypeMap);
  }
}

export namespace ResumeFailed {}
export class ResumeFrom extends Resume {
  "from"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "from",
      baseName: "from",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(ResumeFrom.attributeTypeMap);
  }
}

export namespace ResumeFrom {}
export class TemporalUnit {
  "timeBased"?: boolean;
  "duration"?: Duration;
  "dateBased"?: boolean;
  "durationEstimated"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "timeBased",
      baseName: "timeBased",
      type: "boolean"
    },
    {
      name: "duration",
      baseName: "duration",
      type: "Duration"
    },
    {
      name: "dateBased",
      baseName: "dateBased",
      type: "boolean"
    },
    {
      name: "durationEstimated",
      baseName: "durationEstimated",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return TemporalUnit.attributeTypeMap;
  }
}

export class ZoneId {
  "rules"?: ZoneRules;
  "id"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "rules",
      baseName: "rules",
      type: "ZoneRules"
    },
    {
      name: "id",
      baseName: "id",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return ZoneId.attributeTypeMap;
  }
}

export class ZoneOffset {
  "totalSeconds"?: number;
  "id"?: string;
  "rules"?: ZoneRules;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "totalSeconds",
      baseName: "totalSeconds",
      type: "number"
    },
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "rules",
      baseName: "rules",
      type: "ZoneRules"
    }
  ];

  static getAttributeTypeMap() {
    return ZoneOffset.attributeTypeMap;
  }
}

export class ZoneOffsetTransition {
  "offsetBefore"?: ZoneOffset;
  "offsetAfter"?: ZoneOffset;
  "overlap"?: boolean;
  "instant"?: number;
  "gap"?: boolean;
  "dateTimeBefore"?: Date;
  "dateTimeAfter"?: Date;
  "duration"?: Duration;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "offsetBefore",
      baseName: "offsetBefore",
      type: "ZoneOffset"
    },
    {
      name: "offsetAfter",
      baseName: "offsetAfter",
      type: "ZoneOffset"
    },
    {
      name: "overlap",
      baseName: "overlap",
      type: "boolean"
    },
    {
      name: "instant",
      baseName: "instant",
      type: "number"
    },
    {
      name: "gap",
      baseName: "gap",
      type: "boolean"
    },
    {
      name: "dateTimeBefore",
      baseName: "dateTimeBefore",
      type: "Date"
    },
    {
      name: "dateTimeAfter",
      baseName: "dateTimeAfter",
      type: "Date"
    },
    {
      name: "duration",
      baseName: "duration",
      type: "Duration"
    }
  ];

  static getAttributeTypeMap() {
    return ZoneOffsetTransition.attributeTypeMap;
  }
}

export class ZoneOffsetTransitionRule {
  "month"?: ZoneOffsetTransitionRule.MonthEnum;
  "timeDefinition"?: ZoneOffsetTransitionRule.TimeDefinitionEnum;
  "standardOffset"?: ZoneOffset;
  "offsetBefore"?: ZoneOffset;
  "offsetAfter"?: ZoneOffset;
  "dayOfWeek"?: ZoneOffsetTransitionRule.DayOfWeekEnum;
  "dayOfMonthIndicator"?: number;
  "localTime"?: LocalTime;
  "midnightEndOfDay"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "month",
      baseName: "month",
      type: "ZoneOffsetTransitionRule.MonthEnum"
    },
    {
      name: "timeDefinition",
      baseName: "timeDefinition",
      type: "ZoneOffsetTransitionRule.TimeDefinitionEnum"
    },
    {
      name: "standardOffset",
      baseName: "standardOffset",
      type: "ZoneOffset"
    },
    {
      name: "offsetBefore",
      baseName: "offsetBefore",
      type: "ZoneOffset"
    },
    {
      name: "offsetAfter",
      baseName: "offsetAfter",
      type: "ZoneOffset"
    },
    {
      name: "dayOfWeek",
      baseName: "dayOfWeek",
      type: "ZoneOffsetTransitionRule.DayOfWeekEnum"
    },
    {
      name: "dayOfMonthIndicator",
      baseName: "dayOfMonthIndicator",
      type: "number"
    },
    {
      name: "localTime",
      baseName: "localTime",
      type: "LocalTime"
    },
    {
      name: "midnightEndOfDay",
      baseName: "midnightEndOfDay",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return ZoneOffsetTransitionRule.attributeTypeMap;
  }
}

export namespace ZoneOffsetTransitionRule {
  export enum MonthEnum {
    JANUARY = <any>"JANUARY",
    FEBRUARY = <any>"FEBRUARY",
    MARCH = <any>"MARCH",
    APRIL = <any>"APRIL",
    MAY = <any>"MAY",
    JUNE = <any>"JUNE",
    JULY = <any>"JULY",
    AUGUST = <any>"AUGUST",
    SEPTEMBER = <any>"SEPTEMBER",
    OCTOBER = <any>"OCTOBER",
    NOVEMBER = <any>"NOVEMBER",
    DECEMBER = <any>"DECEMBER"
  }
  export enum TimeDefinitionEnum {
    UTC = <any>"UTC",
    WALL = <any>"WALL",
    STANDARD = <any>"STANDARD"
  }
  export enum DayOfWeekEnum {
    MONDAY = <any>"MONDAY",
    TUESDAY = <any>"TUESDAY",
    WEDNESDAY = <any>"WEDNESDAY",
    THURSDAY = <any>"THURSDAY",
    FRIDAY = <any>"FRIDAY",
    SATURDAY = <any>"SATURDAY",
    SUNDAY = <any>"SUNDAY"
  }
}
export class ZoneRules {
  "transitions"?: Array<ZoneOffsetTransition>;
  "transitionRules"?: Array<ZoneOffsetTransitionRule>;
  "fixedOffset"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "transitions",
      baseName: "transitions",
      type: "Array<ZoneOffsetTransition>"
    },
    {
      name: "transitionRules",
      baseName: "transitionRules",
      type: "Array<ZoneOffsetTransitionRule>"
    },
    {
      name: "fixedOffset",
      baseName: "fixedOffset",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return ZoneRules.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {
  "OffsetDateTime.DayOfWeekEnum": OffsetDateTime.DayOfWeekEnum,
  "OffsetDateTime.MonthEnum": OffsetDateTime.MonthEnum,
  "Resume.ModeEnum": Resume.ModeEnum,
  "ZoneOffsetTransitionRule.MonthEnum": ZoneOffsetTransitionRule.MonthEnum,
  "ZoneOffsetTransitionRule.TimeDefinitionEnum":
    ZoneOffsetTransitionRule.TimeDefinitionEnum,
  "ZoneOffsetTransitionRule.DayOfWeekEnum":
    ZoneOffsetTransitionRule.DayOfWeekEnum
};

let typeMap: { [index: string]: any } = {
  Attempt: Attempt,
  Config: Config,
  ConfigFactory: ConfigFactory,
  DirectUploadHandle: DirectUploadHandle,
  Duration: Duration,
  Id: Id,
  IdAndName: IdAndName,
  InputStream: InputStream,
  LocalTime: LocalTime,
  LocalTimeOrInstant: LocalTimeOrInstant,
  NameOptionalId: NameOptionalId,
  OffsetDateTime: OffsetDateTime,
  RestDirectDownloadHandle: RestDirectDownloadHandle,
  RestLogFileHandle: RestLogFileHandle,
  RestLogFileHandleCollection: RestLogFileHandleCollection,
  RestLogFilePutResult: RestLogFilePutResult,
  RestProject: RestProject,
  RestProjectCollection: RestProjectCollection,
  RestRevision: RestRevision,
  RestRevisionCollection: RestRevisionCollection,
  RestSchedule: RestSchedule,
  RestScheduleBackfillRequest: RestScheduleBackfillRequest,
  RestScheduleCollection: RestScheduleCollection,
  RestScheduleSkipRequest: RestScheduleSkipRequest,
  RestScheduleSummary: RestScheduleSummary,
  RestSecretList: RestSecretList,
  RestSession: RestSession,
  RestSessionAttempt: RestSessionAttempt,
  RestSessionAttemptCollection: RestSessionAttemptCollection,
  RestSessionAttemptRequest: RestSessionAttemptRequest,
  RestSessionCollection: RestSessionCollection,
  RestSetSecretRequest: RestSetSecretRequest,
  RestTask: RestTask,
  RestTaskCollection: RestTaskCollection,
  RestVersionCheckResult: RestVersionCheckResult,
  RestWorkflowDefinition: RestWorkflowDefinition,
  RestWorkflowDefinitionCollection: RestWorkflowDefinitionCollection,
  RestWorkflowSessionTime: RestWorkflowSessionTime,
  Resume: Resume,
  ResumeFailed: ResumeFailed,
  ResumeFrom: ResumeFrom,
  TemporalUnit: TemporalUnit,
  ZoneId: ZoneId,
  ZoneOffset: ZoneOffset,
  ZoneOffsetTransition: ZoneOffsetTransition,
  ZoneOffsetTransitionRule: ZoneOffsetTransitionRule,
  ZoneRules: ZoneRules
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum AdminApiApiKeys {}

export class AdminApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AdminApiApiKeys, value: string) {
    (this.authentications as any)[AdminApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getUserInfo(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Config }> {
    const localVarPath =
      this.basePath +
      "/api/admin/attempts/{id}/userinfo".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getUserInfo."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Config }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Config");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum AttemptApiApiKeys {}

export class AttemptApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AttemptApiApiKeys, value: string) {
    (this.authentications as any)[AttemptApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getAttempt(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestSessionAttempt }> {
    const localVarPath =
      this.basePath +
      "/api/attempts/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getAttempt."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionAttempt;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestSessionAttempt");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getAttemptRetries(
    id: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestSessionAttemptCollection;
  }> {
    const localVarPath =
      this.basePath +
      "/api/attempts/{id}/retries".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getAttemptRetries."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionAttemptCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestSessionAttemptCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param project
   * @param workflow
   * @param includeRetried
   * @param lastId
   * @param pageSize
   * @param {*} [options] Override http request options.
   */
  public getAttempts(
    project?: string,
    workflow?: string,
    includeRetried?: boolean,
    lastId?: number,
    pageSize?: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestSessionAttemptCollection;
  }> {
    const localVarPath = this.basePath + "/api/attempts";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (project !== undefined) {
      localVarQueryParameters["project"] = ObjectSerializer.serialize(
        project,
        "string"
      );
    }

    if (workflow !== undefined) {
      localVarQueryParameters["workflow"] = ObjectSerializer.serialize(
        workflow,
        "string"
      );
    }

    if (includeRetried !== undefined) {
      localVarQueryParameters["include_retried"] = ObjectSerializer.serialize(
        includeRetried,
        "boolean"
      );
    }

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionAttemptCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestSessionAttemptCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getTasks(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestTaskCollection }> {
    const localVarPath =
      this.basePath +
      "/api/attempts/{id}/tasks".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getTasks."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestTaskCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestTaskCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public killAttempt(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/api/attempts/{id}/kill".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling killAttempt."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param body
   * @param {*} [options] Override http request options.
   */
  public startAttempt(
    body?: RestSessionAttemptRequest,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/api/attempts";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RestSessionAttemptRequest")
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum LogApiApiKeys {}

export class LogApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: LogApiApiKeys, value: string) {
    (this.authentications as any)[LogApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param attemptId
   * @param fileName
   * @param {*} [options] Override http request options.
   */
  public getFile(
    attemptId: number,
    fileName: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/api/logs/{attempt_id}/files/{file_name}"
        .replace(
          "{" + "attempt_id" + "}",
          encodeURIComponent(String(attemptId))
        )
        .replace("{" + "file_name" + "}", encodeURIComponent(String(fileName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'attemptId' is not null or undefined
    if (attemptId === null || attemptId === undefined) {
      throw new Error(
        "Required parameter attemptId was null or undefined when calling getFile."
      );
    }

    // verify required parameter 'fileName' is not null or undefined
    if (fileName === null || fileName === undefined) {
      throw new Error(
        "Required parameter fileName was null or undefined when calling getFile."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param attemptId
   * @param task
   * @param fileTime
   * @param nodeId
   * @param {*} [options] Override http request options.
   */
  public getFileHandles(
    attemptId: number,
    task?: string,
    fileTime?: number,
    nodeId?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: DirectUploadHandle }> {
    const localVarPath =
      this.basePath +
      "/api/logs/{attempt_id}/upload_handle".replace(
        "{" + "attempt_id" + "}",
        encodeURIComponent(String(attemptId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'attemptId' is not null or undefined
    if (attemptId === null || attemptId === undefined) {
      throw new Error(
        "Required parameter attemptId was null or undefined when calling getFileHandles."
      );
    }

    if (task !== undefined) {
      localVarQueryParameters["task"] = ObjectSerializer.serialize(
        task,
        "string"
      );
    }

    if (fileTime !== undefined) {
      localVarQueryParameters["file_time"] = ObjectSerializer.serialize(
        fileTime,
        "number"
      );
    }

    if (nodeId !== undefined) {
      localVarQueryParameters["node_id"] = ObjectSerializer.serialize(
        nodeId,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DirectUploadHandle;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "DirectUploadHandle");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param attemptId
   * @param task
   * @param {*} [options] Override http request options.
   */
  public getFileHandlesFiles(
    attemptId: number,
    task?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestLogFileHandleCollection;
  }> {
    const localVarPath =
      this.basePath +
      "/api/logs/{attempt_id}/files".replace(
        "{" + "attempt_id" + "}",
        encodeURIComponent(String(attemptId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'attemptId' is not null or undefined
    if (attemptId === null || attemptId === undefined) {
      throw new Error(
        "Required parameter attemptId was null or undefined when calling getFileHandlesFiles."
      );
    }

    if (task !== undefined) {
      localVarQueryParameters["task"] = ObjectSerializer.serialize(
        task,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestLogFileHandleCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestLogFileHandleCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param attemptId
   * @param task
   * @param fileTime
   * @param nodeId
   * @param body
   * @param {*} [options] Override http request options.
   */
  public putFile(
    attemptId: number,
    task?: string,
    fileTime?: number,
    nodeId?: string,
    body?: InputStream,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestLogFilePutResult }> {
    const localVarPath =
      this.basePath +
      "/api/logs/{attempt_id}/files".replace(
        "{" + "attempt_id" + "}",
        encodeURIComponent(String(attemptId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'attemptId' is not null or undefined
    if (attemptId === null || attemptId === undefined) {
      throw new Error(
        "Required parameter attemptId was null or undefined when calling putFile."
      );
    }

    if (task !== undefined) {
      localVarQueryParameters["task"] = ObjectSerializer.serialize(
        task,
        "string"
      );
    }

    if (fileTime !== undefined) {
      localVarQueryParameters["file_time"] = ObjectSerializer.serialize(
        fileTime,
        "number"
      );
    }

    if (nodeId !== undefined) {
      localVarQueryParameters["node_id"] = ObjectSerializer.serialize(
        nodeId,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "InputStream")
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestLogFilePutResult;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestLogFilePutResult");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum ProjectApiApiKeys {}

export class ProjectApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ProjectApiApiKeys, value: string) {
    (this.authentications as any)[ProjectApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public deleteProject(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestProject }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deleteProject."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: RestProject }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "RestProject");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param id
   * @param key
   * @param {*} [options] Override http request options.
   */
  public deleteProjectSecret(
    id: number,
    key: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/secrets/{key}"
        .replace("{" + "id" + "}", encodeURIComponent(String(id)))
        .replace("{" + "key" + "}", encodeURIComponent(String(key)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deleteProjectSecret."
      );
    }

    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined) {
      throw new Error(
        "Required parameter key was null or undefined when calling deleteProjectSecret."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param id
   * @param revision
   * @param {*} [options] Override http request options.
   */
  public getArchive(
    id: number,
    revision?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/archive".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getArchive."
      );
    }

    if (revision !== undefined) {
      localVarQueryParameters["revision"] = ObjectSerializer.serialize(
        revision,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param name
   * @param {*} [options] Override http request options.
   */
  public getProject(
    name?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestProject }> {
    const localVarPath = this.basePath + "/api/project";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: RestProject }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "RestProject");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getProjectSecrets(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestSecretList }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/secrets".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getProjectSecrets."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSecretList;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestSecretList");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param name
   * @param {*} [options] Override http request options.
   */
  public getProjects(
    name?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestProjectCollection }> {
    const localVarPath = this.basePath + "/api/projects";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestProjectCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestProjectCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getProjectsById(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestProject }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getProjectsById."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: RestProject }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "RestProject");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param id
   * @param lastId
   * @param {*} [options] Override http request options.
   */
  public getRevisions(
    id: number,
    lastId?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestRevisionCollection }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/revisions".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getRevisions."
      );
    }

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestRevisionCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestRevisionCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param workflow
   * @param lastId
   * @param {*} [options] Override http request options.
   */
  public getSchedules(
    id: number,
    workflow?: string,
    lastId?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestScheduleCollection }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/schedules".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSchedules."
      );
    }

    if (workflow !== undefined) {
      localVarQueryParameters["workflow"] = ObjectSerializer.serialize(
        workflow,
        "string"
      );
    }

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestScheduleCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestScheduleCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param workflow
   * @param lastId
   * @param pageSize
   * @param {*} [options] Override http request options.
   */
  public getSessionsByProjectId(
    id: number,
    workflow?: string,
    lastId?: number,
    pageSize?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestSessionCollection }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/sessions".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSessionsByProjectId."
      );
    }

    if (workflow !== undefined) {
      localVarQueryParameters["workflow"] = ObjectSerializer.serialize(
        workflow,
        "string"
      );
    }

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestSessionCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param name
   * @param revision
   * @param {*} [options] Override http request options.
   */
  public getWorkflow(
    id: number,
    name?: string,
    revision?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestWorkflowDefinition }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/workflow".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWorkflow."
      );
    }

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    if (revision !== undefined) {
      localVarQueryParameters["revision"] = ObjectSerializer.serialize(
        revision,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowDefinition;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestWorkflowDefinition");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param name
   * @param revision
   * @param {*} [options] Override http request options.
   */
  public getWorkflowByName(
    id: number,
    name: string,
    revision?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestWorkflowDefinition }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/workflows/{name}"
        .replace("{" + "id" + "}", encodeURIComponent(String(id)))
        .replace("{" + "name" + "}", encodeURIComponent(String(name)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWorkflowByName."
      );
    }

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
      throw new Error(
        "Required parameter name was null or undefined when calling getWorkflowByName."
      );
    }

    if (revision !== undefined) {
      localVarQueryParameters["revision"] = ObjectSerializer.serialize(
        revision,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowDefinition;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestWorkflowDefinition");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param revision
   * @param name
   * @param {*} [options] Override http request options.
   */
  public getWorkflows(
    id: number,
    revision?: string,
    name?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestWorkflowDefinitionCollection;
  }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/workflows".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWorkflows."
      );
    }

    if (revision !== undefined) {
      localVarQueryParameters["revision"] = ObjectSerializer.serialize(
        revision,
        "string"
      );
    }

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowDefinitionCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestWorkflowDefinitionCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param project
   * @param revision
   * @param body
   * @param contentLength
   * @param scheduleFrom
   * @param {*} [options] Override http request options.
   */
  public putProject(
    project?: string,
    revision?: string,
    body?: InputStream,
    contentLength?: number,
    scheduleFrom?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestProject }> {
    const localVarPath = this.basePath + "/api/projects";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (project !== undefined) {
      localVarQueryParameters["project"] = ObjectSerializer.serialize(
        project,
        "string"
      );
    }

    if (revision !== undefined) {
      localVarQueryParameters["revision"] = ObjectSerializer.serialize(
        revision,
        "string"
      );
    }

    if (scheduleFrom !== undefined) {
      localVarQueryParameters["schedule_from"] = ObjectSerializer.serialize(
        scheduleFrom,
        "string"
      );
    }

    localVarHeaderParams["Content-Length"] = ObjectSerializer.serialize(
      contentLength,
      "number"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "InputStream")
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: RestProject }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "RestProject");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param id
   * @param key
   * @param body
   * @param {*} [options] Override http request options.
   */
  public putProjectSecret(
    id: number,
    key: string,
    body?: RestSetSecretRequest,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/api/projects/{id}/secrets/{key}"
        .replace("{" + "id" + "}", encodeURIComponent(String(id)))
        .replace("{" + "key" + "}", encodeURIComponent(String(key)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling putProjectSecret."
      );
    }

    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined) {
      throw new Error(
        "Required parameter key was null or undefined when calling putProjectSecret."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RestSetSecretRequest")
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ScheduleApiApiKeys {}

export class ScheduleApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ScheduleApiApiKeys, value: string) {
    (this.authentications as any)[ScheduleApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param id
   * @param body
   * @param {*} [options] Override http request options.
   */
  public backfillSchedule(
    id: number,
    body?: RestScheduleBackfillRequest,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestSessionAttemptCollection;
  }> {
    const localVarPath =
      this.basePath +
      "/api/schedules/{id}/backfill".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling backfillSchedule."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RestScheduleBackfillRequest")
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionAttemptCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestSessionAttemptCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public disableSchedule(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestScheduleSummary }> {
    const localVarPath =
      this.basePath +
      "/api/schedules/{id}/disable".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling disableSchedule."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestScheduleSummary;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestScheduleSummary");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public enableSchedule(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestScheduleSummary }> {
    const localVarPath =
      this.basePath +
      "/api/schedules/{id}/enable".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling enableSchedule."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestScheduleSummary;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestScheduleSummary");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getSchedulesById(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestSchedule }> {
    const localVarPath =
      this.basePath +
      "/api/schedules/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSchedulesById."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: RestSchedule }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "RestSchedule");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param lastId
   * @param {*} [options] Override http request options.
   */
  public getSchedulesSearch(
    lastId?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestScheduleCollection }> {
    const localVarPath = this.basePath + "/api/schedules";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestScheduleCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestScheduleCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param body
   * @param {*} [options] Override http request options.
   */
  public skipSchedule(
    id: number,
    body?: RestScheduleSkipRequest,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestScheduleSummary }> {
    const localVarPath =
      this.basePath +
      "/api/schedules/{id}/skip".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling skipSchedule."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RestScheduleSkipRequest")
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestScheduleSummary;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestScheduleSummary");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum SessionApiApiKeys {}

export class SessionApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SessionApiApiKeys, value: string) {
    (this.authentications as any)[SessionApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getSession(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestSession }> {
    const localVarPath =
      this.basePath +
      "/api/sessions/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSession."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: RestSession }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "RestSession");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @param id
   * @param lastId
   * @param pageSize
   * @param {*} [options] Override http request options.
   */
  public getSessionAttempts(
    id: number,
    lastId?: number,
    pageSize?: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestSessionAttemptCollection;
  }> {
    const localVarPath =
      this.basePath +
      "/api/sessions/{id}/attempts".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSessionAttempts."
      );
    }

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionAttemptCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestSessionAttemptCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param lastId
   * @param pageSize
   * @param {*} [options] Override http request options.
   */
  public getSessions(
    lastId?: number,
    pageSize?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestSessionCollection }> {
    const localVarPath = this.basePath + "/api/sessions";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestSessionCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestSessionCollection");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum VersionApiApiKeys {}

export class VersionApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: VersionApiApiKeys, value: string) {
    (this.authentications as any)[VersionApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param client
   * @param {*} [options] Override http request options.
   */
  public checkClientVersion(
    client?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestVersionCheckResult }> {
    const localVarPath = this.basePath + "/api/version/check";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (client !== undefined) {
      localVarQueryParameters["client"] = ObjectSerializer.serialize(
        client,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestVersionCheckResult;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestVersionCheckResult");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param {*} [options] Override http request options.
   */
  public getVersion(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: { [key: string]: any } }> {
    const localVarPath = this.basePath + "/api/version";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: { [key: string]: any };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum WorkflowApiApiKeys {}

export class WorkflowApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    basicAuth: new HttpBasicAuth()
  };

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: WorkflowApiApiKeys, value: string) {
    (this.authentications as any)[WorkflowApiApiKeys[key]].apiKey = value;
  }
  set username(username: string) {
    this.authentications.basicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.basicAuth.password = password;
  }
  /**
   *
   * @param id
   * @param sessionTime
   * @param mode
   * @param {*} [options] Override http request options.
   */
  public getWorkflowDefinition(
    id: number,
    sessionTime?: string,
    mode?: "SECOND" | "MINUTE" | "HOUR" | "DAY" | "SCHEDULE" | "NEXT_SCHEDULE",
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestWorkflowSessionTime;
  }> {
    const localVarPath =
      this.basePath +
      "/api/workflows/{id}/truncated_session_time".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWorkflowDefinition."
      );
    }

    if (sessionTime !== undefined) {
      localVarQueryParameters["session_time"] = ObjectSerializer.serialize(
        sessionTime,
        "string"
      );
    }

    if (mode !== undefined) {
      localVarQueryParameters["mode"] = ObjectSerializer.serialize(
        mode,
        "'SECOND' | 'MINUTE' | 'HOUR' | 'DAY' | 'SCHEDULE' | 'NEXT_SCHEDULE'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowSessionTime;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestWorkflowSessionTime");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param id
   * @param {*} [options] Override http request options.
   */
  public getWorkflowDefinitionById(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestWorkflowDefinition }> {
    const localVarPath =
      this.basePath +
      "/api/workflows/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWorkflowDefinitionById."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowDefinition;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestWorkflowDefinition");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param project
   * @param revision
   * @param name
   * @param {*} [options] Override http request options.
   */
  public getWorkflowDefinitionSearch(
    project?: string,
    revision?: string,
    name?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RestWorkflowDefinition }> {
    const localVarPath = this.basePath + "/api/workflow";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (project !== undefined) {
      localVarQueryParameters["project"] = ObjectSerializer.serialize(
        project,
        "string"
      );
    }

    if (revision !== undefined) {
      localVarQueryParameters["revision"] = ObjectSerializer.serialize(
        revision,
        "string"
      );
    }

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowDefinition;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RestWorkflowDefinition");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @param lastId
   * @param count
   * @param {*} [options] Override http request options.
   */
  public getWorkflowDefinitions(
    lastId?: number,
    count?: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: RestWorkflowDefinitionCollection;
  }> {
    const localVarPath = this.basePath + "/api/workflows";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (lastId !== undefined) {
      localVarQueryParameters["last_id"] = ObjectSerializer.serialize(
        lastId,
        "number"
      );
    }

    if (count !== undefined) {
      localVarQueryParameters["count"] = ObjectSerializer.serialize(
        count,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.basicAuth.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RestWorkflowDefinitionCollection;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "RestWorkflowDefinitionCollection"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
