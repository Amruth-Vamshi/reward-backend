directive @auth(requires: [PermissionMap]) on FIELD_DEFINITION

enum ACCESS_TYPE {
  PRIVATE
  PUBLIC
}

type Action {
  id: ID
  actionDefinition: ActionDefinition
  organization: Organization
  request: JSON
  response: JSON
  status: String
}

type ActionDefinition {
  id: ID
  name: String
  type: String
  organization: Organization
  configuration: JSON
  code: String
  inputSchema: JSON
  outputSchema: JSON
  status: String
}

type ActionDefinitionPage {
  data: [ActionDefinition!]
  paginationInfo: PaginationInfo
}

type ActionPage {
  data: [Action!]
  paginationInfo: PaginationInfo
}

input addAudienceMemberInput {
  audience_id: ID!
  customer_id: ID!
  status: STATUS!
}

input addCampaignControl {
  organization_id: ID!
  customer_id: ID!
  campaign_id: ID!
  startTime: DateTime!
  endTime: DateTime!
  status: STATUS!
}

input AddEntityExtend {
  organization_id: ID!
  entity_name: EXTEND_ENTITIES!
  description: String!
}

input AddEntityExtendField {
  entityExtendId: ID!
  slug: String!
  label: String
  help: String
  type: SLUGTYPE!
  required: Boolean
  choices: [String]
  defaultValue: String
  description: String
  searchable: Boolean
  validator: String
}

input addGlobalControl {
  organization_id: ID!
  customer_id: ID!
  startTime: DateTime!
  endTime: DateTime!
}

input AddVariableToMessageTemplateInput {
  organization_id: ID!
  templateId: ID!
  templateVariableId: ID!
}

type APIKey {
  id: ID!
  environment: String
  status: String
  roles: [Role]
  api_key: String
}

input APIKeyInput {
  id: ID!
  environment: EnvironmentEnum
  status: STATUS
}

"""
Skeloton of the Application data sent back to the user
"""
type Application {
  """
  Unique id of the application
  """
  id: ID!

  """
  Name of the application
  """
  name: String

  """
  Description of the organization
  """
  description: String

  """
  auth_key_hooks associated with this application
  """
  auth_key_hooks: String

  """
  Platform this application will run on
  """
  platform: String

  """
  Data of the organization to which the application belongs
  """
  organization: Organization

  """
  Actions associated with this application
  """
  actions: [Action]
  apiKeys: APIKey
}

input ApplicationInput {
  """
  Name of the application
  """
  name: String!

  """
  Description of the organization
  """
  description: String

  """
  auth_key_hooks associated with this application
  """
  auth_key_hooks: String

  """
  Platform this application will run on
  """
  platform: String
}

"""
Skeloton of the input receive by server to update Application
"""
input ApplicationUpdateInput {
  """
  Unique id of the application
  """
  id: ID!

  """
  Name of the application
  """
  name: String

  """
  Description of the organization
  """
  description: String

  """
  auth_key_hooks associated with this application
  """
  auth_key_hooks: String

  """
  Platform this application will run on
  """
  platform: String
}

type Audience {
  id: ID
  campaign: Campaign
  segment: Segment
  organization: Organization
  application: Application
  status: STATUS
}

type AudienceCountOutput {
  count: Int
}

type AudienceMember {
  id: ID!
  audience: Audience!
  customer: Customer!
  status: STATUS!
}

type BasicField {
  slug: String
  label: String
  type: SLUGTYPE
  required: Boolean
  defaultValue: String
  searchable: Boolean
  description: String
}

enum BUSINESS_RULE_LEVELS {
  ORGANIZATION
  STORE
  APPLICATION
  LOYALTY
}

type BusinessRule {
  id: ID!
  ruleLevel: BUSINESS_RULE_LEVELS!
  ruleType: String!
  ruleDefaultValue: String
}

input BusinessRuleConfigurationInput {
  ruleLevel: BUSINESS_RULE_LEVELS
  ruleLevelId: String
  ruleType: String
  organizationId: String!
}

type BusinessRuleDetail {
  id: ID!
  ruleLevel: BUSINESS_RULE_LEVELS!
  ruleLevelId: String!
  ruleType: String!
  ruleValue: String
}

type Campaign {
  createdBy: String
  lastModifiedBy: String
  createdTime: DateTime
  lastModifiedTime: DateTime
  id: ID!
  name: String
  description: String
  startTime: DateTime
  endTime: DateTime
  organization: Organization
  application: Application
  campaignType: String
  triggerRule: Rule
  status: STATUS
  priority: Int
  campaignStatus: String
  audienceFilterRule: Rule
  feedbackForm: FeedbackForm
}

enum CAMPAIGN_STATUS {
  DRAFT
  CLOSED
  PAUSE
  LIVE
  UPCOMING
  COMPLETE
  PRE_LIVE_PROCESSING
}

enum CAMPAIGN_TRIGGER_TYPE {
  SCHEDULED
  EVENT
}

enum CAMPAIGN_TYPE {
  OFFER
  FEEDBACK
  MESSAGING
  LOYALTY
}

type CampaignControl {
  id: ID!
  organization: Organization
  customer: Customer
  campaign: Campaign
  startTime: DateTime
  endTime: DateTime
  status: STATUS
}

input CampaignOfferInput {
  offerId: ID!
  campaignId: ID!
  status: STATUS
  organizationId: ID!
}

type CampaignOfferOutput {
  id: ID
  offer: Offer
  campaign: Campaign
  startDate: DateTime
  endDate: DateTime
  status: STATUS
  organization: Organization
}

type CampaignOfferPage {
  data: [CampaignOfferOutput]
  paginationInfo: PaginationInfo
}

type CampaignsOutput {
  campaign: Campaign
  audienceCount: Int
  reached: Int
  redemptionRate: Int
}

input CampaignUpdateInput {
  name: String
  description: String
  campaignType: CAMPAIGN_TYPE
  priority: Int
  campaignTriggerType: CAMPAIGN_TRIGGER_TYPE
  triggerRule: ID
  isCampaignControlEnabled: Boolean
  campaignControlPercent: Int
  isGlobalControlEnabled: Boolean
  startTime: DateTime
  endTime: DateTime
  audienceFilterRule: ID
}

input CampaingAddInput {
  name: String!
  description: String
  campaignType: CAMPAIGN_TYPE!
  priority: Int
  campaignTriggerType: CAMPAIGN_TRIGGER_TYPE
  triggerRule: ID
  isCampaignControlEnabled: Boolean
  campaignControlPercent: Int
  isGlobalControlEnabled: Boolean
  startTime: DateTime!
  endTime: DateTime!
  audienceFilterRule: ID
  organization_id: ID!
  application_id: ID
}

input cancelLoyaltyInput {
  externalCustomerId: ID!
  loyaltyReferenceId: ID!
  organizationId: String
}

type CancelLoyaltyTransactionOutput {
  id: String
  status: String
  externalCustomerId: String!
  loyaltyReferenceId: String
  totalPoints: Float
  totalAmount: String
}

type Catalog {
  id: ID!
  name: String
  catalogCode: String
  description: String
  organization: Organization
  usage: CatalogUsage
}

input CatalogInput {
  name: String!
  catalogCode: String!
  description: String
  organizationId: ID!
  usage: CatalogUsageInput
}

type CatalogUsage {
  id: ID
  purpose: String
}

input CatalogUsageInput {
  purpose: String
}

type Category {
  id: ID
  name: String
  description: String
  code: String
  extend: JSON
  catalogId: ID
  status: STATUS
  products: [Product]
  parent: Category
  children: [Category]
  catalog: Catalog
}

input CategoryInput {
  id: ID
  name: String
  description: String
  code: String
  extend: JSON
  status: STATUS
}

input CategorySearchInput {
  name: String
  description: String
  code: String
  status: STATUS
}

type Channel {
  id: ID
  name: String
  organization: Organization
  channelCode: String
  chargeTypes: [Charge]
}

input ChannelFilterInput {
  id: ID
  name: String
  channelCode: String
}

type ChannelPage {
  data: [Channel]
  paginationInfo: PaginationInfo
}

input ChannelTypeInput {
  name: String!
  channelCode: String!
  chargeTypeCode: [String]
}

input ChannelTypeUpdateInput {
  id: ID!
  name: String
  channelCode: String
  chargeTypeCode: [String]
}

type Charge {
  id: ID
  name: String
  organization: Organization
  chargeTypeCode: String
}

input ChargeTypeCreateInput {
  name: String!
  chargeTypeCode: String!
}

input ChargeTypeInput {
  id: ID
  name: String
  chargeTypeCode: String
}

input ChargeTypesInput {
  chargeTypeCode: [String]
}

input ChargeTypeUpdateInput {
  id: ID!
  name: String
  chargeTypeCode: String
}

"""
 Skeleton of Choice being send to the user
"""
type Choice {
  id: ID
  fromQuestion: Question
  toQuestion: Question
  choiceText: String
  responses: [Response]
  rangeStart: Int
  rangeEnd: Int
}

"""
 Skeleton of the INput received from user for creating Choice
"""
input ChoiceInput {
  choiceText: String!
  rangeStart: Int
  rangeEnd: Int
}

enum COMBINATOR {
  and
  or
}

type Communication {
  id: ID
  entityId: String
  entityType: COMMUNICATION_ENTITY_TYPE
  messageTemplate: MessageTemplate
  isScheduled: Boolean
  firstScheduleDateTime: DateTime
  isRepeatable: Boolean
  lastProcessedDateTime: DateTime
  repeatRuleConfiguration: RepeatRuleConfigurationOutput
  commsChannelName: String
  organization: Organization
  application: Application
  status: STATUS
  campaign: Campaign
}

enum COMMUNICATION_DAYS {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

enum COMMUNICATION_ENTITY_TYPE {
  CAMPAIGN
  OFFER
  LOYALTY
}

enum COMMUNICATION_FREQUENCY {
  WEEKLY
  MONTHLY
  DAILY
}

enum COMMUNICATION_RUN_TYPE {
  FIRST
  REPEAT
}

enum COMMUNICATION_STATUS {
  ADDED
  STARTED
  ERROR
  COMPLETE
}

type CommunicationLog {
  communication: Communication
  startTime: DateTime
  endTime: DateTime
  runType: COMMUNICATION_RUN_TYPE
  communicationStatus: COMMUNICATION_STATUS
  log: JSON
}

input CommunicationLogInput {
  communicationId: ID!
  startTime: DateTime!
  runType: COMMUNICATION_RUN_TYPE!
  logMessage: String!
}

input CommunicationLogUpdateInput {
  communicationLogId: ID!
  communicationStatus: COMMUNICATION_STATUS!
  logMessage: String!
}

type ConfirmEmailResponse {
  userId: String
  email: String
  verified: Boolean
}

input CreateActionDefinitionInput {
  name: String!
  type: String!
  organizationId: ID!
  configuration: JSON!
  code: String
  inputSchema: JSON!
  outputSchema: JSON!
  status: String
}

input createAudienceInput {
  campaign_id: ID!
  segment_id: [ID]!
  organization_id: ID!
  application_id: ID
  status: STATUS!
}

type CreateBulkCustomerResponse {
  savedCustomers: [Customer]
  validationErrors: [ValidationError]
}

input CreateBusinessRuleDetailInput {
  ruleLevel: BUSINESS_RULE_LEVELS!
  ruleLevelId: String!
  ruleType: String!
  ruleValue: String
  organizationId: String!
}

input CreateBusinessRuleInput {
  ruleLevel: BUSINESS_RULE_LEVELS!
  ruleType: String!
  ruleDefaultValue: String
}

input CreateCategoryInput {
  name: String!
  description: String!
  status: STATUS!
  code: String!
  extend: JSON
  catalogId: ID!
  parentId: ID
  organizationId: String!
}

input CreateCommunicationInput {
  entityId: String!
  entityType: COMMUNICATION_ENTITY_TYPE
  messageTemplateId: ID!
  isScheduled: Boolean!
  firstScheduleDateTime: DateTime
  isRepeatable: Boolean!
  lastProcessedDateTime: DateTime
  repeatRuleConfiguration: RepeatRuleConfiguration
  commsChannelName: String!
  organization_id: ID!
  application_id: ID
  campaign_id: ID!
  status: STATUS!
}

input CreateCommunicationWithoutMessageTemplateIdInput {
  entityId: String!
  entityType: COMMUNICATION_ENTITY_TYPE
  isScheduled: Boolean!
  firstScheduleDateTime: DateTime
  isRepeatable: Boolean!
  lastProcessedDateTime: DateTime
  repeatRuleConfiguration: RepeatRuleConfiguration
  commsChannelName: String!
  organization_id: ID!
  application_id: ID
  status: STATUS!
}

input CreateCommunicationWithoutMessageTemplateInput {
  entityId: String!
  entityType: COMMUNICATION_ENTITY_TYPE
  isScheduled: Boolean!
  firstScheduleDateTime: DateTime
  isRepeatable: Boolean!
  lastProcessedDateTime: DateTime
  repeatRuleConfiguration: RepeatRuleConfiguration
  commsChannelName: String!
  organization_id: ID!
  campaign_id: ID!
  application_id: ID
  status: STATUS!
}

input CreateCustomerSessionInput {
  customerId: String!
}

type CreateCustomerSessionOutput {
  customerId: String!
  token: String!
}

input CreateFileSystemInput {
  name: String!
  description: String!
  accessType: ACCESS_TYPE!
  fileSystemType: FILE_SYSTEM_TYPE!
  configuration: JSON!
  enabled: Boolean!
  organizationId: ID!
}

input CreateLoyaltyProgramInput {
  name: String
  loyaltyCode: String!
  loyaltyCardCode: String!
  organizationId: String
  expiryUnit: ExpiryUnit
  expiryValue: Int
  earnRuleConfiguration: JSON
  burnRuleConfiguration: JSON
  expiryRuleConfiguration: JSON
  campaign: CampaingAddInput!
}

input CreateMessageTemplateInput {
  name: String!
  description: String!
  messageFormat: MESSAGE_FORMAT!
  templateBodyText: String!
  templateSubjectText: String!
  templateStyle: TEMPLATE_STYLE!
  organization_id: ID!
  url: String
  imageUrl: String
  status: STATUS!
}

input CreateMessageTemplateVariableInput {
  name: String!
  key: String!
  type: VARIABLE_TYPE!
  format: VARIABLE_FORMAT
  defaultValue: String
  required: Boolean!
  organization_id: ID!
  status: STATUS!
}

input CreateOrganizationInput {
  name: String!
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalOrganizationId: String
  code: String!
  status: STATUS!
  phoneNumber: String
  website: String
  extend: JSON
  organizationType: OrganizationTypeEnum!
}

input CreateProductInput {
  code: String!
  name: String!
  description: String
  organizationId: ID!
  imageUrl: String
  type: ProductTypeEnum
  sku: String
  status: STATUS!
  extend: JSON
  categoryIds: [ID]!
  optionIds: [ID]
  variants: [CreateProductVariantInput!]
}

input CreateProductVariantInput {
  sku: String!
  optionValueIds: [ID!]!
}

"""
Skeleton of data received on server for creating a Response
"""
input CreateResponseInput {
  responseData: JSON
}

input CreateRuleAttributeInput {
  attributeName: String!
  description: String
  status: STATUS!
  attributeValueType: VALUE_TYPE!
  ruleEntityId: ID!
  organizationId: ID!
}

input CreateRuleEntityInput {
  entityName: String!
  entityCode: String
  status: STATUS!
  organizationId: ID!
}

input CreateRuleInput {
  name: String!
  description: String
  type: RULE_TYPE!
  status: STATUS
  ruleConfiguration: JSON
  ruleExpression: JSON
  organizationId: ID!
}

input CreateStoreAdminLevel {
  name: String!
  code: String!
  parentId: ID
}

input CreateStoreInput {
  name: String
  STATUS: STATUS
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalStoreId: String
  extend: JSON
  code: String!
  email: String
  wifi: Boolean
  latitude: String
  longitude: String
  adminLevelId: String
  parentOrganizationId: String!
  storeFormatCode: String
  catalogCode: String
  channelCode: String
}

type Currency {
  id: ID!

  """
  Unique code to identify the currency
  """
  code: String

  """
  Conversion Ratio between loyalty points and actual tender
  eg. Conversion ratio of 1 would mean 1 loyalty point
  """
  conversionRatio: Float

  """
  Name of the currency
  """
  name: String
}

input CurrencyCreateInput {
  """
  Unique code to identify the currency
  """
  code: String!

  """
  Conversion Ratio between loyalty points and actual tender
  eg. Conversion ratio of 1 would mean 1 loyalty point
  """
  conversionRatio: Float

  """
  Name of the currency
  """
  name: String!
}

type CurrencyPage {
  data: [Currency]
  paginationInfo: PaginationInfo
}

input CurrencyUpdateInput {
  id: ID

  """
  Unique code to identify the currency
  """
  code: String!

  """
  Conversion Ratio between loyalty points and actual tender
  eg. Conversion ratio of 1 would mean 1 loyalty point
  """
  conversionRatio: Float

  """
  Name of the currency
  """
  name: String
}

type Customer {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  gender: String
  dateOfBirth: String
  externalCustomerId: String
  customerIdentifier: String
  organization: Organization
  extend: JSON
  onboardSource: String
  customerDevices: [CustomerDevice]
}

type CustomerColumn {
  column_slug: String
  column_search_key: String
  column_label: String
  column_type: String
  searchable: Boolean
  extended_column: Boolean
}

type CustomerDefnition {
  entityName: String
  searchEntityName: String
  columns: [CustomerColumn]
}

type CustomerDevice {
  id: ID
  fcmToken: String
  deviceId: String
  modelNumber: String
  osVersion: String
  status: String
  extend: JSON
  organization: Organization
  customer: Customer
}

input CustomerDeviceInput {
  id: String
  fcmToken: String
  customer_id: String
  osVersion: String
  deviceId: String
  extend: JSON
  modelNumber: String
}

"""
Skeleton of the Customer Feedback received by the user
"""
type CustomerFeedback {
  id: ID!
  createdTime: Date
  customer: Customer
  feedbackForm: FeedbackForm
  response: [Response]
  completed: Boolean
  event: Event
  expiryDate: Date
}

type CustomerFeedbackResponse {
  data: [CustomerFeedback]
  paginationInfo: PaginationInfo
}

input CustomerFields {
  id: ID
  firstName: String
  lastName: String
  email: String
  phoneNumer: String
  gender: String
  dateOfBirth: String
  organization_id: String
  status: STATUS
}

input CustomerFieldSearch {
  id: ID
  attributeName: String
  attributeValue: String
  expressionType: EXPRESSION_TYPE
}

input CustomerFileUploadInput {
  file: Upload!
  segmentName: String
  organizationId: String
}

input CustomerInput {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String!
  gender: GENDER
  dateOfBirth: String
  externalCustomerId: String
  customerIdentifier: String
  organization: ID!
  extend: JSON
  onboard_source: String
}

type CustomerLedgerOutput {
  createdTime: DateTime
  lastModifiedTime: DateTime
  id: ID
  loyaltyTransaction: CustomerLoyaltyTransaction
  loyaltyLedger: LoyaltyLedger
}

"""
@deprecated Type might not be used
"""
type CustomerLoyalty {
  id: ID
  points: Float
  pointsBlocked: Float
  customer: Customer
}

input CustomerLoyaltyInput {
  """
  CustomerId maintained by external systems
  """
  externalCustomerId: String

  """
  Extra data that can be used for implementation
  """
  extraData: JSON

  """
  LoyaltyCardCode that uniquely identifies the LoyaltyCard
  """
  loyaltyCardCode: String

  """
  UUID for the organization
  """
  organizationId: ID

  """
  If True, the API creates Customer & Customer Loyalty if customer doesn't exist
  """
  createCustomerIfNotExist: Boolean
}

type CustomerLoyaltyOutput {
  createdTime: Date
  lastModifiedTime: Date

  """
  CustomerId maintained by external systems
  """
  externalCustomerId: String

  """
  Overall Loyalty Points belonging to the customer
  """
  overallPoints: Float

  """
  Loyalty Points that are immediately burnable. It can be different
  from overallPoints if some points are blocked and is signified by blockedPoints.
  """
  burnablePoints: Float

  """
  Overall Tender amount belonging to the customer. It is calculated by applying conversionRatio
  on the loyalty points
  """
  overallAmount: Float

  """
  BurnableAmount = BurnablePoints * conversionRatio
  """
  burnableAmount: Float

  """
  Loyalty Points blocked as part of a transaction
  """
  pointsBlocked: Float

  """
  BlockedAmount = BlockedPoints * conversionRatio
  """
  blockedAmount: Float

  """
  Code for the loyalty card
  """
  loyaltyCardCode: String

  """
  JFL Implementation Identifies if customer loyalty account is enabled or not
  """
  loyaltyEnabled: Boolean
}

type CustomerLoyaltyTransaction {
  id: ID!

  """
  Auto-generated transaction description
  """
  name: String

  """
  Unique loyalty reference Id. This is generated externally when a transaction is created
  """
  loyaltyReferenceId: String

  """
  Loyalty Type
  """
  loyaltyType: String

  """
  StatusCode of the transaction
  """
  status: String

  """
  Additional data stored as part of transaction
  """
  data: JSON

  """
  Points Blocked as part of the transaction. This is temporary field and will be updated
  if points are unblocked
  """
  pointsBlocked: Float

  """
  Points issued as part of the transaction
  """
  pointsIssued: Float

  """
  Points redeemed as part of the transaction
  """
  pointsRedeemed: Float
  customerLoyalty: CustomerLoyalty
}

type CustomerLoyaltyTransactionData {
  id: String
  statusCode: LoyaltyStatus
  code: String
  pointsBlocked: Float
  pointsIssued: Float
  pointsRedeemed: Float
  loyaltyReferenceId: String
  type: String
  name: String
  loyaltyLedgers: [LoyaltyLedger]
  customerLoyalty: CustomerLoyaltyOutput
  loyaltyProgram: LoyaltyProgram
  data: JSON
}

type CustomerOfferPage {
  data: [CustomerOffersOutput]
  paginationInfo: PaginationInfo
}

input CustomerOffersInput {
  campaignId: ID!
  offerId: ID!
  customerId: ID!
  coupon: String
  status: STATUS
  organizationId: ID
}

type CustomerOffersOutput {
  id: ID
  campaign: Campaign
  offer: Offer
  customer: Customer
  coupon: String
  status: STATUS
  organizationId: Organization
}

input CustomerSearchFilters {
  rules: [CustomerFieldSearch]
  combinator: COMBINATOR
}

type CustomerSearchOutput {
  data: [JSON]
  total: Int
  page: Int
}

scalar Date

scalar DateTime

enum DB_SOURCE {
  CORE
  WAREHOUSE
}

type DeletedChoice {
  choiceText: String
  rangeStart: Int
  rangeEnd: Int
}

type DeletedFeedbackTemplateUrl {
  title: String
  description: String
  url: String
  status: STATUS
}

type DeleteOrganization {
  name: String!
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalOrganizationId: String
  code: String
  status: STATUS!
  phoneNumber: String
  website: String
  extend: JSON
  organizationType: OrganizationTypeEnum
}

input DisableActionDefinitionInput {
  id: ID!
  organizationId: ID
}

type EarnableBurnableLoyaltyTransactionOutput {
  earnablePoints: Float
  burnablePoints: Float
  earnableAmount: String
  burnableAmount: String
  overallPoints: Float
  overallAmount: String
  loyaltyEnabled: Boolean
  earnedPointsExpiryValue: String
  earnedPointsExpiryUnit: String
}

input EarnableLoyaltyTransactionInput {
  statusCode: String!
  organizationId: String
  externalCustomerId: String!
  loyaltyCode: String!
  loyaltyCardCode: String!
  burnFromLoyaltyCard: Boolean!
  loyaltyReferenceId: String!
  externalTransationId: String!
  createCustomerIfNotExist: Boolean
  orderData: JSON
  transactionData: Transaction
}

type EarnableLoyaltyTransactionOutput {
  loyaltyCardCode: String
  earnablePoints: Float
  burnablePoints: Float
  earnableAmount: Float
  burnableAmount: Float
  loyaltyReferenceId: String
  blockedPoints: Float
}

"""
 Skeleton of Input being received from user editing choices
"""
input EditChoiceInput {
  id: ID!
  choiceText: String
  rangeStart: Int
  rangeEnd: Int
}

"""
 Skeleton of Input being received from user editing questions
"""
input EditQuestionInput {
  id: ID!
  questionText: String
  type: Question_Type_Enum
  rangeMin: Int
  rangeMax: Int
}

"""
Skeleton of data received on server for updating a Response
"""
input EditResponseInput {
  id: ID!
  questionData: JSON
  responseData: JSON
}

input EndSessionInput {
  id: ID!
}

enum ENTITY_TYPE {
  INITIATED
  FAILED
  SUCCESS
  TERMINATED
  CANCELLED
  JSON
  XML
  NOTIFICATION
  EXTERNAL_API
  CREATE_CUSTOMER_FEEDBACK_FORM
  Organization
  Product
  Category
  Order
  Store
  Customer
  Campaign
  Segment
  Event
  EventType
}

type EntityExtend {
  id: ID!
  entityName: EXTEND_ENTITIES!
  description: String!
  organization: Organization!
  fields: [EntityExtendField]
}

type EntityExtendField {
  id: ID!
  slug: String!
  label: String
  help: String
  type: SLUGTYPE!
  required: Boolean!
  choices: [String]
  defaultValue: String
  description: String
  searchable: Boolean
  validator: String
}

enum EnvironmentEnum {
  TEST
  PRODUCTION
  DEVELOPMENT
}

type Event {
  id: ID
  sourceEventId: String
  sourceEventTime: Date
  sourceName: String
  data: JSON
  metadata: JSON
  eventType: EventType
  processedStatus: JSON
}

input EventCustomerDeviceInput {
  fcmToken: String
  deviceId: String
  osVersion: String
  modelNumber: String
}

input EventCustomerInput {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  gender: String
  dateOfBirth: String
  externalCustomerId: String
  customerIdentifier: String!
  onboard_source: String
  status: String
}

input EventInput {
  sourceEventId: String
  sourceEventTime: Date
  sourceName: String
  data: JSON
  metadata: JSON
  eventTypeCode: String!
}

type EventSubscription {
  id: ID!
  triggerAction: TriggerActionEnum
  customAction: Action
  eventType: EventType
  sync: Boolean
  status: String
}

type EventType {
  id: ID!
  code: String
  description: String
  status: STATUS
  application: Application
  eventSubscriptions: [EventSubscription]
  events: [Event]
}

enum ExpiryUnit {
  HOUR
  DAY
  MONTH
  YEAR
}

enum EXPRESSION_TYPE {
  EQUALS
  NOT_EQUALS
  LESS_THAN
  GREATER_THAN
  LESS_THAN_OR_EQUAL
  GREATER_THAN_OR_EQUAL
  LIKE
  IN
}

enum EXTEND_ENTITIES {
  Customer
  CustomerSearch
  CustomerDevice
  Product
  Store
  Organization
  User
  Session
  Category
}

"""
Skeleton of the feedback category received by user
STILL IN DEVELOPMENT
"""
type FeedbackCategory {
  id: ID
  title: String
  children: [FeedbackCategory]
  parent: FeedbackCategory
  organization: Organization
  feedbackHandler: FeedbackHandler
  questions: [Question]
}

"""
Skeleton of the data received by the server to create a feedback category
STILL IN DEVELOPMENT
"""
input FeedbackCategoryInput {
  title: String
}

"""
Skeleton of Feedback form being sent to user
"""
type FeedbackForm {
  id: ID!

  """
  This is just used as an identifier for the feedback form
  """
  title: String
  questionnaireRoot: Question
  customerFeedbacks: [CustomerFeedback]
  campaign: Campaign
  feedbackUIConfig: FeedbackUIConfig

  """
  Use this flag to tell the system wether it should automatically create customer or not,
  in case the incoming event has a phonenumber/fcm which is not mapped to any customer in the system
  """
  autoCreateCustomer: Boolean
  feedbackTemplateURL: FeedbackTemplateUrl
  expireAfter: FormExpiry
  firebaseDynamicLinkPrefix: String
  firebaseDynamicLinkAPIURL: String
  fireBaseAPIKey: String
  createMultipleFeedbacks: Boolean
}

"""
Skeleton of Input receive from user to create a feedback form
"""
input FeedbackFormCreateInput {
  """
  This is just used as an identifier for the feedback form
  """
  title: String

  """
  Use this flag to tell the system wether it should automatically create customer or not,
  in case the incoming event has a phonenumber/fcm which is not mapped to any customer in the system
  """
  autoCreateCustomer: Boolean
  expireAfter: FormExpiryInput
  firebaseDynamicLinkPrefix: String
  firebaseDynamicLinkAPIURL: String
  fireBaseAPIKey: String
  createMultipleFeedbacks: Boolean
}

type FeedbackFormsResponse {
  data: [FeedbackForm]
  paginationInfo: PaginationInfo
}

"""
Skeleton of Input receive from user to update a feedback form
"""
input FeedbackFormUpdateInput {
  id: ID!

  """
  This is just used as an identifier for the feedback form
  """
  title: String

  """
  Use this flag to tell the system wether it should automatically create customer or not,
  in case the incoming event has a phonenumber/fcm which is not mapped to any customer in the system
  """
  autoCreateCustomer: Boolean
  expireAfter: FormExpiryInput
  firebaseDynamicLinkPrefix: String
  firebaseDynamicLinkAPIURL: String
  fireBaseAPIKey: String
  createMultipleFeedbacks: Boolean
}

type FeedbackHandler {
  title: String
  category: FeedbackCategory
}

input FeedbackResponse {
  choiceIds: [ID]!
  responseData: JSON
  questionId: ID!
}

type FeedbackTemplateUrl {
  id: ID!
  title: String
  description: String
  url: String
  status: STATUS
  feedbackForms: [FeedbackForm]
}

type FeedbackUIConfig {
  id: ID
  layoutCode: String
  backgroundColor: String
  accentColor: String
  transition: String
  logoUrl: String
  formStructure: String
  headerText: String
  exitMessage: String
  buttonText: String
  feedbackForm: FeedbackForm
}

input FeedbackUIConfigUpdateInput {
  layoutCode: String
  backgroundColor: String
  accentColor: String
  transition: String
  logoUrl: String
  formStructure: String
  headerText: String
  exitMessage: String
  buttonText: String
}

type File {
  id: ID!
  name: String
  mimeType: String
  encoding: String
  description: String
  internalUrl: String
  publicUrl: String
  status: STATUS
  organization: Organization
  fileSystem: FileSystem
}

enum FILE_SYSTEM_TYPE {
  S3
  CLOUDINARY
}

type FilesPage {
  data: [File!]
  paginationInfo: PaginationInfo
}

type FileSystem {
  id: ID
  name: String
  description: String
  accessType: ACCESS_TYPE
  fileSystemType: FILE_SYSTEM_TYPE
  configuration: JSON
  enabled: Boolean
  status: STATUS
  organization: Organization
}

type FileSystemsPage {
  data: [FileSystem!]
  paginationInfo: PaginationInfo
}

input FileUploadInput {
  file: Upload!
  description: String
  fileSystemId: String
  organizationId: String
}

enum FORMAT {
  JSON
  XML
}

type FormatMessage {
  templateId: ID
  variables: JSON
  bodyText: String
  subjectText: String
  templateStyle: TEMPLATE_STYLE
}

input FormatMessageInput {
  organization_id: ID!
  templateId: ID!
  variables: JSON!
}

type FormExpiry {
  value: Int
  unit: UnitOfTime
}

input FormExpiryInput {
  value: Int!
  unit: UnitOfTime!
}

enum GENDER {
  MALE
  FEMALE
  OTHERS
}

type GlobalControl {
  id: ID!
  organization: Organization
  customer: Customer
  startTime: DateTime
  endTime: DateTime
  status: STATUS
}

input HyperXCampaignInput {
  organizationId: ID
  applicationId: ID
  campaignType: [String]
  campaignStatus: CAMPAIGN_STATUS
  status: STATUS
}

type HyperXOutput {
  id: ID!
  version: Int
  initStatus: String
}

type InitCustomerFeedbackData {
  customerFeedback: CustomerFeedback
  feedbackForm: FeedbackForm
  questions: [Question]
}

type InitFeedbackFormData {
  feedbackForm: FeedbackForm
  questions: [Question]
}

scalar JSON

type JWT {
  jwt: String!
}

type LedgerOutput {
  data: [CustomerLedgerOutput]
  ledgerCount: Int
  externalCustomerId: String
  dateStart: DateTime
  dateEnd: DateTime
  page: Int
  itemsPerPage: Int
  orderBy: SORTING_DIRECTIONS
  loyaltyCardCode: String
}

input LoginInput {
  email: String!
  password: String!
}

type LoyaltyCard {
  id: ID!

  """
  Unique code to identify the LoyaltyCard
  """
  code: String

  """
  Description for the LoyaltyCard
  """
  description: String

  """
  Name of the Loyalty card
  """
  name: String

  """
  Currency associated with the LoyaltyCard
  """
  currency: Currency!

  """
  Organization associated with the LoyaltyCard
  """
  organization: Organization
}

input LoyaltyCardCreateInput {
  """
  Unique code to identify the LoyaltyCard
  """
  code: String!

  """
  Description for the LoyaltyCard
  """
  description: String

  """
  Name of the Loyalty card
  """
  name: String!

  """
  CurrencyCode for the LoyaltyCard
  """
  currencyCode: String!

  """
  UUID of the Organization
  """
  organizationId: String
}

type LoyaltyCardPage {
  data: [LoyaltyCard]
  paginationInfo: PaginationInfo
}

input LoyaltyCardUpdateInput {
  id: ID!

  """
  Unique code to identify the LoyaltyCard
  """
  code: String!

  """
  Description for the LoyaltyCard
  """
  description: String

  """
  Name of the Loyalty card
  """
  name: String!

  """
  CurrencyCode for the LoyaltyCard
  """
  currencyCode: String!

  """
  UUID of the Organization
  """
  organizationId: String
}

type LoyaltyLedger {
  id: ID

  """
  Loyalty ledger points
  """
  points: Float

  """
  Description of ledger entry
  """
  remarks: String

  """
  Snapshot of the balance when ledger entry was created
  This is never updated.
  """
  balanceSnapshot: Float

  """
  Type of ledger entry.
  1. EXPIRED
  2. ISSUE
  3. REDUCE
  """
  type: String

  """
  @deprecated Not using it
  """
  totalAmount: Float

  """
  StoreId of the external system
  """
  externalStoreId: String

  """
  Expiry Date of loyalty points, if type is ISSUE
  """
  expiryDate: DateTime

  """
  Internal calculated field that tells how many points from this ledger is used or expired
  """
  pointsRemaining: Float

  """
  Internal calculated field useful for loyalty burn and expiry.
  """
  details: JSON
}

type LoyaltyLedgerOutputType {
  id: ID

  """
  Loyalty ledger points
  """
  points: Float

  """
  Snapshot of the balance when ledger entry was created
  This is never updated.
  """
  balanceSnapshot: Float

  """
  Internal calculated field that tells how many points from this ledger is used or expired
  """
  pointsRemaining: Float

  """
  Type of ledger entry.
  1. EXPIRED
  2. ISSUE
  3. REDUCE
  """
  type: String

  """
  Expiry Date of loyalty points, if type is ISSUE
  """
  expiryDate: String

  """
  Internal calculated field useful for loyalty burn and expiry.
  """
  details: JSON

  """
  Description of ledger entry
  """
  remarks: String
}

type LoyaltyProgram {
  loyaltyBurnRule: Rule
  loyaltyEarnRule: Rule
  loyaltyExpiryRule: Rule
  expiryUnit: ExpiryUnit
  expiryValue: Int
  campaign: Campaign
  code: String
  loyaltyCode: String

  """
  Code for the loyalty card
  """
  loyaltyCardCode: String

  """
  UUID for the organization
  """
  organizationId: String
  loyaltyCard: LoyaltyCard
}

input LoyaltyProgramInput {
  loyaltyCode: String!

  """
  Code for the loyalty card
  """
  loyaltyCardCode: String

  """
  UUID for the organization
  """
  organizationId: String
}

type LoyaltyProgramPage {
  data: [LoyaltyProgram]
  paginationInfo: PaginationInfo
}

type LoyaltyStatus {
  statusId: Int
  statusCode: String
  statusType: String
  description: String
}

input LoyaltyStatusInput {
  statusId: String!
  statusCode: statusCodes!
  statusType: String
  description: String
}

type LoyaltyStatusOutput {
  statusId: Int
  statusCode: String
  statusType: String
  description: String
}

type LoyaltyTransaction {
  id: String
  statusCode: LoyaltyStatus
  code: String
  pointsBlocked: Float
  pointsIssued: Float
  pointsRedeemed: Float
  loyaltyReferenceId: String
  type: String
  name: String
  loyaltyLedgers: [LoyaltyLedger]
  customerLoyalty: CustomerLoyaltyOutput
  loyaltyProgram: LoyaltyProgram
}

type LoyaltyTransactionPage {
  data: [CustomerLoyaltyTransactionData]
  paginationInfo: PaginationInfo
}

type Member {
  applicationId: ID
  application: Application
  user: User
  Role: String
}

enum MESSAGE_FORMAT {
  SMS
  PUSH
  EMAIL
}

type MessageTemplate {
  id: ID!
  name: String
  description: String
  messageFormat: MESSAGE_FORMAT
  templateBodyText: String
  templateSubjectText: String
  templateStyle: TEMPLATE_STYLE
  organization: Organization
  messageTemplateVariables: [MessageTemplateVariable]
  status: STATUS
}

type MessageTemplateVariable {
  id: ID!
  name: String
  key: String
  type: VARIABLE_TYPE!
  format: VARIABLE_FORMAT!
  defaultValue: String
  required: Boolean
  organization: Organization
  status: STATUS
}

type Metric {
  id: ID
  name: String
  description: String
  query: String
  type: METRIC_TYPE
  filters: [MetricFilter]
  organization: Organization
  status: STATUS
  source: DB_SOURCE
}

enum METRIC_FILTER_TYPE {
  NUMBER
  STRING
  DATETIME
}

enum METRIC_TYPE {
  SCALAR
  SEQUENCE
  MATRIX
}

input MetricAddInput {
  name: String!
  description: String!
  query: String!
  type: METRIC_TYPE!
  filters: [String]!
  organizationId: ID
  source: DB_SOURCE!
}

type MetricExecutionResult {
  name: String
  type: METRIC_TYPE
  rows: Int
  cols: Int
  headers: [String]
  data: JSON
  total: Int
}

type MetricExecutionResultPage {
  data: [MetricExecutionResult]
  paginationInfo: PaginationInfo
}

type MetricFilter {
  id: ID
  name: String
  key: String
  type: METRIC_FILTER_TYPE
  status: STATUS
  organization: Organization
}

input MetricFilterAddInput {
  key: String!
  name: String!
  type: METRIC_FILTER_TYPE!
  organizationId: ID
}

type MetricFilterPage {
  data: [MetricFilter]
  paginationInfo: PaginationInfo
}

input MetricFilterUpdateInput {
  id: ID!
  name: String
  type: METRIC_FILTER_TYPE
  key: String
  status: STATUS
  organizationId: ID!
}

type MetricPage {
  data: [Metric!]
  paginationInfo: PaginationInfo
}

input MetricUpdateInput {
  id: ID!
  name: String
  description: String
  query: String
  organizationId: ID!
  type: METRIC_TYPE
  filters: [String]
  status: STATUS
  source: DB_SOURCE
}

"""
 Mutation is used to Add, Edit or Delete data on server
"""
type Mutation {
  createMetric(input: MetricAddInput): Metric
  updateMetric(input: MetricUpdateInput): Metric
  createMetricFilter(input: MetricFilterAddInput): MetricFilter
  updateMetricFilter(input: MetricFilterUpdateInput): MetricFilter
  createWebhookEventType(input: WebhookEventTypeAddInput): WebhookEvent
  updateWebhookEventType(input: WebhookEventTypeUpdateInput): WebhookEvent
  createWebhook(input: WebhookAddInput): Webhook
  updateWebhook(input: WebhookUpdateInput): Webhook
  createWebhookEventData(input: WebhookEventDataAddInput): WebhookEventData
  updateWebhookEventData(input: WebhookEventDataUpdateInput): WebhookEventData
  createUser(
    input: UserCreateInput!
    createOrganization: CreateOrganizationInput
    walkinProducts: [walkinProducts]
  ): User
  updateUser(input: UserUpdateInput): User
  deleteUserById(id: String): Boolean
  linkApplicationToUser(userId: String, applicationID: String): User
  addUserToOrganization(
    userData: UserCreateInput!
    organization_id: ID!
    role_id: ID
  ): User
  updatePassword(
    oldPassword: String
    newPassword: String
  ): UpdatePasswordResponse
  confirmEmail(email: String, emailToken: String): ConfirmEmailResponse
  sendPasswordResetLink(email: String): ResetPasswordResponse
  createOrganization(
    organizationInput: CreateOrganizationInput!
    parentId: ID
    walkinProducts: [walkinProducts]
    adminUserInput: UserCreateInput
  ): Organization
  deleteOrganization(id: ID!): DeleteOrganization!
  updateOrganization(organization: UpdateOrganizationInput!): Organization!
  deleteOrganizationHierarchy(id: ID!): [DeleteOrganization]
  linkUserToOrganization(organizationId: ID!, userId: ID!): Organization
  linkOrganizationToparent(organizationId: ID!, parentId: ID!): Organization
  linkOrganizationToWalkinProducts(
    organizationId: ID!
    walkinProducts: [walkinProducts]
  ): Organization
  linkOrganizationToMetrics(
    organizationId: ID!
    walkinProducts: [walkinProducts]
  ): [Metric]

  """
  Generate a API key for the application
  """
  generateAPIKey(
    """
    Unique id of the application for which API key needs to be generated
    """
    id: ID!
    environment: String
  ): APIKey

  """
  Delete an application from the database
  """
  deleteApplication(
    """
    Unique id of the application which needs to be deleted
    """
    id: ID!
  ): Boolean

  """
  Update information of already existing application
  """
  updateApplication(input: ApplicationUpdateInput!): Application
  updateAPIKey(input: APIKeyInput): APIKey

  """
   Create an application for an organization
  """
  createApplication(
    """
     Unique id of the organization for which application needs to created
    """
    organizationId: ID!
    input: ApplicationInput!
  ): Application
  login(input: LoginInput!): JWT!
  logout(input: Boolean): Boolean
  refreshToken(jwt: String!): JWT!
  addRole(input: RoleInput!): Role
  editRole(input: RoleEditInput!): Role
  deleteRole(id: ID!): Role
  addPolicyToRole(roleId: ID!, input: PolicyInput!): Policy
  addPoliciesToRole(roleId: ID!, inputs: [PolicyInput]!): Role
  removePolicyFromRole(roleId: ID!, policyId: ID!): Role
  removePoliciesFromRole(roleId: ID!, policyIds: [ID!]!): Role
  editPolicy(input: PolicyEditInput!): Policy
  linkUserToRole(roleId: ID!, userId: ID!): User
  linkUsersToRole(roleId: ID!, userIds: [ID!]!): [User]
  linkRolesToUser(roleIds: [ID!]!, userId: ID!): User
  unlinkUserToRole(roleId: ID!, userId: ID!): User
  unlinkUsersFromRole(roleId: ID!, userIds: [ID!]!): [User]
  unlinkRolesFromUser(roleIds: [ID!]!, userId: ID!): User
  createStoreAdminLevel(input: CreateStoreAdminLevel!): StoreAdminLevel
  updateStoreAdminLevel(input: UpdateStoreAdminLevel!): StoreAdminLevel
  updateStore(input: UpdateStoreInput!): Store
  createStore(input: CreateStoreInput!): Store
  updateStoreByCode(input: CreateStoreInput!): Store
  pushEvents(events: [EventInput]!): [Event]
  processEventById(id: ID!): JSON
  createEventSubscription(
    eventTypeId: ID!
    triggerAction: TriggerActionEnum!
    customActionId: ID
  ): EventSubscription
  deleteEventSubscription(id: ID!): TypeDeleteEventSubscription
  createEventType(
    code: String!
    description: String
    applicationId: ID!
  ): EventType
  updateEventType(
    id: ID!
    code: String
    description: String
    status: STATUS
  ): EventType
  deleteEventType(id: ID!): TypeDeleteEvent
  createRuleEntity(input: CreateRuleEntityInput!): RuleEntity
  disableRuleEntity(id: ID!): RuleEntity
  createRuleAttribute(input: CreateRuleAttributeInput!): RuleAttribute
  disableRuleAttribute(id: ID!): RuleAttribute
  createRule(input: CreateRuleInput!): Rule
  updateRule(id: ID!, input: UpdateRuleInput!): Rule
  disableRule(id: ID!): Rule
  createBusinessRule(input: CreateBusinessRuleInput): BusinessRule
  updateBusinessRule(id: ID!, input: UpdateBusinessRuleInput): BusinessRule
  deleteBusinessRule(id: ID!): BusinessRule
  createBusinessRuleDetail(
    input: CreateBusinessRuleDetailInput
  ): BusinessRuleDetail
  updateBusinessRuleDetail(
    id: ID!
    input: UpdateBusinessRuleDetailInput
  ): BusinessRuleDetail
  deleteBusinessRuleDetail(id: ID!): BusinessRuleDetail
  updateBusinessRuleByRuleType(input: CreateBusinessRuleInput): BusinessRule
  createWorkflow(input: WorkflowInput): Workflow
  createWorkflowWithChildren(input: WorkflowWithChildrenInput): Workflow
  updateWorkflow(input: UpdateWorkflowInput): Workflow
  createWorkflowProcess(input: WorkflowProcessInput): WorkflowProcess
  updateWorkflowProcess(input: UpdateWorkflowProcessInput): WorkflowProcess
  createWorkflowProcessTransition(
    input: WorkflowProcessTransitionInput
  ): WorkflowProcessTransition
  updateWorkflowProcessTransition(
    input: UpdateWorkflowProcessTransitionInput
  ): WorkflowProcessTransition
  createWorkflowState(input: WorkflowStateInput): WorkflowState
  updateWorkflowState(input: UpdateWorkflowStateInput): WorkflowState
  createWorkflowEntity(input: WorkflowEntityInput): WorkflowEntity
  updateWorkflowEntity(input: UpdateWorkflowEntityInput): WorkflowEntity
  addWorkflowEnityTransitionStatus(
    input: WorkflowEntityTransitionInput
  ): WorkflowEntityTransition
  createWorkflowRoute(input: WorkflowRouteInput): WorkflowRoute
  updateWorkflowRoute(input: UpdateWorkflowRouteInput): WorkflowRoute
  createCustomer(customer: CustomerInput!): Customer
  createBulkCustomer(customers: [CustomerInput]!): CreateBulkCustomerResponse
  updateCustomer(customer: UpdateCustomerInput): UpdateCustomer
  createCustomerDevice(customerDevice: CustomerDeviceInput!): CustomerDevice
  updateCustomerDevice(
    customerDevice: UpdateCustomerDeviceInput!
  ): CustomerDevice
  disableCustomer(customer: CustomerInput!): Customer
  disableCustomerDevice(customerDevice: CustomerDeviceInput!): CustomerDevice
  uploadFileForCreateBulkCustomer(
    input: CustomerFileUploadInput
  ): UploadFileForCreateBulkCustomerResponse

  """
   Creates new entry for entityExtend
  """
  addEntityExtend(input: AddEntityExtend!): EntityExtend

  """
   Creates new entry for entity extend fields
  """
  addEntityExtendField(input: AddEntityExtendField!): EntityExtendField
  createActionDefinition(input: CreateActionDefinitionInput): ActionDefinition
  updateActionDefinition(input: UpdateActionDefinitionInput): ActionDefinition
  disableActionDefinition(id: ID!, organizationId: ID): Int
  executeAction(actionDefinitionName: String!, request: JSON): Action
  startSession(input: StartSessionInput): Session
  endSession(input: EndSessionInput): Session
  createSegmentForCustomers(
    customerPhoneNumbers: [String]
    segmentName: String
  ): Segment
  createSegment(input: SegmentAddInput): Segment
  updateSegment(input: SegmentUpdateInput): Segment
  disableSegment(id: ID!): Segment
  createCampaign(input: CampaingAddInput): Campaign
  updateCampaign(id: ID!, input: CampaignUpdateInput): Campaign
  launchCampaign(id: ID!): Campaign
  preprocessLaunchCampaign(id: ID!): Campaign
  pauseCampaign(id: ID!): Campaign
  unpauseCampaign(id: ID!): Campaign
  completeCampaign(id: ID!): Campaign
  abandonCampaign(id: ID!): Campaign
  disableCampaign(id: ID!): Campaign
  linkCampaignToApplication(campaignId: ID!, applicationId: ID!): Campaign
  unlinkCampaignFromApplication(campaignId: ID!, applicationId: ID!): Campaign
  jobManageEndedCampaigns: Boolean
  createAudience(input: createAudienceInput): [Audience]
  updateAudience(input: updateAudienceInput): Audience
  createAudienceForCampaign(campaignId: ID, segments: [ID]!): [Audience]
  createCampaignControl(input: addCampaignControl): CampaignControl
  updateCampaignControl(input: updateCampaignControl): CampaignControl
  createGlobalControl(input: addGlobalControl): GlobalControl
  deactivateGlobalControl(id: ID!): GlobalControl
  createAudienceMember(input: addAudienceMemberInput): AudienceMember
  updateAudienceMember(input: updateAudienceMemberInput): AudienceMember
  createFileSystem(input: CreateFileSystemInput!): FileSystem
  updateFileSystem(input: UpdateFileSystemInput!): FileSystem
  deleteFileSystem(id: ID!, organizationId: ID): Boolean
  generateSignedUploadURL(input: SignedUploadURLInput!): SignedURL
  uploadFile(input: FileUploadInput!): File
  updateFile(file: Upload!, input: UpdateUploadFileInput!): File
  deleteFile(id: ID!, organizationId: ID): Boolean
  createMessageTemplate(input: CreateMessageTemplateInput!): MessageTemplate
  updateMessageTemplate(input: UpdateMessageTemplateInput!): MessageTemplate
  createMessageTemplateVariable(
    input: CreateMessageTemplateVariableInput!
  ): MessageTemplateVariable
  updateMessageTemplateVariable(
    input: UpdateMessageTemplateVariableInput!
  ): MessageTemplateVariable
  addVariableToMessageTemplate(
    input: AddVariableToMessageTemplateInput!
  ): MessageTemplate
  removeVariableFromMessageTemplate(
    input: RemoveVariableFromMessageTemplateInput!
  ): MessageTemplate
  formatMessage(input: FormatMessageInput!): FormatMessage
  sendMessage(input: SendMessageInput!): Boolean
  createCommunicationWithMessageTempate(
    communicationInput: CreateCommunicationWithoutMessageTemplateInput!
    messageTemplateInput: CreateMessageTemplateInput
  ): Communication
  updateCommunicationWithMessageTempate(
    communicationInput: UpdateCommunicationInput!
    messageTemplateInput: UpdateMessageTemplateInput
  ): Communication
  createCommunication(input: CreateCommunicationInput!): Communication
  updateCommunication(input: UpdateCommunicationInput!): Communication
  disableCommunication(id: ID!, organization: ID!): Communication
  addCommunicationLog(input: CommunicationLogInput!): CommunicationLog
  updateCommunicationLog(input: CommunicationLogUpdateInput!): CommunicationLog
  createCatalog(input: CatalogInput!): Catalog!
  updateCatalog(input: UpdateCatalogInput!): Catalog!
  createCategory(input: CreateCategoryInput!): Category!
  updateCategory(input: UpdateCategoryInput!): Category!
  disableCategory(id: ID!): Category!
  createOption(input: OptionInput): Option
  updateOption(input: UpdateOptionInput): Option
  createOptionValue(input: OptionValueInput): OptionValue
  updateOptionValue(input: UpdateOptionValueInput): OptionValue
  createProduct(input: CreateProductInput!): Product
  updateProduct(input: UpdateProductInput!): Product
  disableProduct(productName: String!): Product
  createCategoryProductOption(
    input: CategoryProductOptionInput
  ): CategoryProductOption
  updateCategoryProductOption(
    input: UpdateCategoryProductOptionInput
  ): CategoryProductOption
  createProductVariant(input: ProductVariantInput): ProductVariant
  updateProductVariant(input: UpdateProductVariantInput): ProductVariant
  createProductVariantValue(
    input: ProductVariantValueInput
  ): ProductVariantValue
  updateProductVariantValue(
    input: UpdateProductVariantValueInput
  ): ProductVariantValue
  createProductCategory(input: ProductCategoryInput): ProductCategory
  updateProductCategory(input: UpdateProductCategoryInput): ProductCategory
  createChargeType(input: ChargeTypeCreateInput): Charge
  updateChargeType(input: ChargeTypeUpdateInput): Charge
  deleteChargeType(id: ID!): Boolean
  createChannel(input: ChannelTypeInput): Channel
  updateChannel(input: ChannelTypeUpdateInput): Channel
  deleteChannel(id: ID!): Boolean
  createTaxType(input: TaxTypeInput): TaxType
  updateTaxType(id: ID!, input: TaxTypeInput): TaxType
  createStoreFormat(input: StoreFormatInput): StoreFormat
  updateStoreFormat(id: ID!, input: StoreFormatInput): StoreFormat
  addReportConfig(
    name: String!
    description: String!
    organizationId: ID!
  ): ReportConfig
  deactivateReportConfig(id: ID!, organizationId: ID!): Boolean
  addReport(
    reportConfigId: ID!
    reportFileId: ID!
    reportDate: Date!
    organizationId: ID!
  ): Report
  deleteReport(id: ID!, organizationId: ID!): Boolean
  addOfferToCampaign(input: CampaignOfferInput): CampaignOfferOutput
  removeOfferFromCampaign(
    input: updateCampaignOfferInput
  ): [CampaignOfferOutput]
  createCustomerOffer(input: CustomerOffersInput!): CustomerOffersOutput
  updateCustomerOffer(input: updateCustomerOffersInput!): CustomerOffersOutput
  deactivateCustomerOffer(id: ID!): CustomerOffersOutput
  createOffer(input: OfferInput): Offer
  updateOffer(input: updateOfferInput): Offer
  launchOffer(id: ID!): Offer
  closeOffer(id: ID!): Offer
  redeemOffer(input: RedeemOfferInput): RedemptionOutput
  initializeHyperX(organizationId: ID!): HyperXOutput

  """
  Creates a feedback form
  This creates a feedback form for the inputs provided which needs to exist inorder to send ,
  it also contains the starting points for the questionnaire. Which needs to be attached seperatley.
  """
  createFeedbackForm(
    """
    Unique id of the campaign
    """
    campaignId: ID!
    input: FeedbackFormCreateInput!

    """
    This is the id of the deployed feedback Template. You can get this from the feedbackTemplates Query
    You can connecty a template later as well using linkFeedbackFormToFeedbackTemplate
    """
    feedbackTemplateId: ID
  ): FeedbackForm

  """
  Update the feedback form for a campaign,
  You can update any attribute of a feedback form using this API
  """
  updateFeedbackForm(input: FeedbackFormUpdateInput): FeedbackForm

  """
  Delete a feedback form from a campaign
  This api will delete a feedback form, however eventually delete should only mean status changing to inactive
  """
  deleteFeedbackForm(
    """
    Unique id of Form which needs to be deleted
    """
    id: ID!
  ): FeedbackForm

  """
  Feedback UI config is an entity auto created when we create a feedback form.
  One feedback form has only one feedback ui config
  it is required to configure the ui for the feedback form, it is read by the
  front end scripts to use these variables and update components in the Feedback Form UI
  There is no find create or delete api for this as the control entirely lies with the feedback form.
  """
  updateFeedbackUIConfig(
    feedbackFormId: ID!
    feedbackUIConfig: FeedbackUIConfigUpdateInput!
  ): FeedbackUIConfig

  """
  This is a very important API  as without linking the feedback form to a
  feedback UI template there will be no rendering of the feedback form
  A feedback form template is just the hosted feedback form, which uses the
  config from the feedback form to personalize it for the user.
  The template also contains the URL which will house the feedback form, Few
  feedback forms are added to the DB in the table feedback_template_url , as a
  part of the factory setup
  and can be used to link here. If a custom ui is used then an entry needs to be
  added in the feedback_template_url table using the createfeedbacktemplate api
  and the saved ID should be used here to link it.
  """
  linkFeedbackFormToFeedbackTemplate(
    feedbackFormId: ID!
    feedbackTemplateId: ID!
  ): FeedbackForm

  """
  The feedback form templates can be delinked before linking it to some other
  feedback form here. It is not adviced to overwrite the linked feedback form
  using the link api
  so it's necessary to unlink before relinking.
  """
  unlinkFeedbackFormFromFeedbackTemplate(
    feedbackFormId: ID!
    feedbackTemplateId: ID!
  ): FeedbackForm

  """
  Will be used to create the feedback root category
  We need to create a feedback category root before adding a node because the feedback category is a tree
  and we need a root node before we can create the childrens.
  STILL IN DEVELOPMENT
  """
  createFeedbackCategoryRoot(
    """
    Unique organization id
    """
    organizationId: ID!

    """
    Title of the feedback category
    """
    input: FeedbackCategoryInput
  ): FeedbackCategory

  """
  Adds a new category to the existing category tree
  Please make sure you have a node or a root before adding a node, as feedback
  category is a tree with 1 root and multiple nodes
  STILL IN DEVELOPMENT
  """
  addFeedbackCategoryNode(
    parentFeedbackCategoryId: ID!
    input: FeedbackCategoryInput
  ): FeedbackCategory

  """
  Update an existing category for feedback
  You can directly update the attributes of a feedback category node using this api
  STILL IN DEVELOPMENT
  """
  updateFeedbackCategory(input: UpdateFeedbackCategoryInput): FeedbackCategory

  """
  Link an existing question to an category
  This is necessary to track the health of a category using all the questions connected to the category, so it is
  necessary to connect feedback category to connect to the questions for analytics and automatic triggers
  STILL IN DEVELOPMENT
  """
  linkFeedbackCategorytoQuestion(
    """
    Unique id of Feedback category
    """
    feedbackCategoryId: ID!

    """
    Unique id of which needs to be Linked to category
    """
    questionId: ID!
  ): FeedbackCategory

  """
  A customer feedback serves as an entity used to track a feedback generated for a customer,
  We also send it as the parameter for customer feedback urls to track the relevant customer feedback
  The url in the www.somefeedbackformdomain.com/customer-feedback-id
  A customer feedback is connected to the feedback form which is connected to the questionnaire
  and CF is also connected to the answers a customer gives, via feedback response.
  You can manually create a customer feedback using this API however, this API is internally called by events framework
  """
  createCustomerFeedback(
    """
    Unique id of the custmer
    """
    customerId: ID

    """
    unique id of the feedback form
    """
    feedbackFormId: ID!
    event_id: ID
  ): CustomerFeedback

  """
  This internal use API is called after an event has been created in the system,
  and if the event is subscribed to REFINEX_SEND_FEEDBACK
  then this mutation is being called, from the event processor.
  """
  refineXSendFeedbackByEventId(eventId: ID!): JSON

  """
  This external use API is called to directly send customer feedback without creating an event
  """
  refineXSendFeedbackByInput(
    campaignId: String!
    customer: EventCustomerInput!
    customerDevice: EventCustomerDeviceInput
    forTest: Boolean
  ): JSON

  """
  Create root or first question for a feedback form , this is being called from the console to create a questionnaire root.
  We define a questionnaire root as the first question of the feedback form, the
  entire questionnaire is a tree, where a question
  hasmany answer which hasone question.
  """
  createQuestionnaire(
    """
     Unique id of the feedback form for which question is being created
    """
    feedbackFormId: ID!

    """
     Input being received from user  creating questions
    """
    input: QuestionInput
  ): Question

  """
  Add a new Question to the database. This is being called from the console on adding new questions to the questionnaire,
  since questionniare is a tree, where a question is connected to a choice which
  is connected to a questionnaire, this needs a choice id for the branching logic
  """
  addQuestion(
    """
     Unique id of the choice which needs to be liked to the question
    """
    choiceId: ID!

    """
     Input being received from user  creating questions
    """
    input: QuestionInput!
  ): Question

  """
  Add a choice for a Question
  Used from the console mainly, to add a choice for a question.
  """
  addChoice(
    """
     Unique question id for which choice needs to be added
    """
    questionId: ID!

    """
     Input being received from user creating choices
    """
    input: ChoiceInput!
  ): [Choice]

  """
  Used to remove a question from the database
  """
  removeQuestion(
    """
     Unique id of the question which needs to be removed
    """
    id: ID!
  ): RemovedQuestion

  """
  Remove a choice from the database .
  """
  removeChoice(
    """
     Unique id of the choice which needs to be removed
    """
    id: ID!
  ): DeletedChoice

  """
  Edit a question already saved in database
  """
  editQuestion(
    """
     Input being received from user editing questions
    """
    input: EditQuestionInput
  ): Question

  """
  Edit a choice already saved in DB
  """
  editChoice(
    """
     Input being received from user editing choices
    """
    input: EditChoiceInput
  ): Choice

  """
  Link a choice to a question , also used to update the relation between the question and the choice.
  """
  linkChoiceToQuestion(
    """
     Unique id of the choice
    """
    choiceId: ID!

    """
     Unique id of the question
    """
    questionId: ID!
  ): Choice

  """
  Submit the response of the User to server
  This api is called from the front end to submit an answer at each page.

         This API will be deprecated in favour of new feedback capture API's
  nextQuestion, previousQuestion and SubmitResponse
  """
  submitResponse(
    """
    Unique id of the customer feedback
    """
    customerFeedbackId: ID!

    """
    Unique id/id's selected by user
    """
    choiceIds: [ID!]!

    """
    data received on server for creating a Response
    """
    input: CreateResponseInput
  ): ResponseSubmit

  """
  Edit the response being submitted by the user
  This api is called to update an already given response.

        This API will be deprecated in favour of new feedback capture API's
  nextQuestion, previousQuestion and SubmitResponse
  """
  updateResponse(
    """
    data received on server for updating a Response
    """
    input: EditResponseInput
  ): ResponseDep

  """
  Intialize refinex for an organization, used when the organization starts using refinex,
  Adds basic workflows and other factory data required for functioning of refinex
  """
  initializeRefineX(
    """
    The organization Id for which we need to enable refinex
    """
    organizationId: ID!
  ): Boolean

  """
  In case a custom feedback UI is being used, this api is called inorder to use
  the custom deployment, in case the feedback form is deployed at some other URL
  please use the updateFeedbackTemplate API to update the database
  """
  addFeedbackTemplateUrl(
    """
    use this field to keep a track of the different templates in your db
    """
    title: String!

    """
    This is the static url of the deployed feedback form, it is used in scenario
    where you want to have a custom UI for your customers to give you feedback.
    In short: This is the UI your users access to give you feedback, generally a weburl
    """
    url: String!

    """
    Just some field to help you make better distinctions between the feedback forms
    """
    description: String
  ): FeedbackTemplateUrl

  """
  This API can update the attributes for the custom deployed template.
  """
  updateFeedbackTemplateUrl(
    id: ID!
    title: String
    description: String
    url: String
    status: STATUS
  ): FeedbackTemplateUrl

  """
  This api is used to delete any custom deployed feedback form template url.
  """
  deleteFeedbackTemplateUrl(id: ID!): FeedbackTemplateUrl
  createFeedbackTemplate(input: FeedbackFormCreateInput): FeedbackForm
  deleteFeedbackTemplate(id: ID!): DeletedFeedbackTemplateUrl
  initCustomerFeedback(customerFeedbackId: ID!): InitCustomerFeedbackData
  previousQuestions(customerFeedbackId: ID!, questionIds: [ID]!): [Question]
  nextQuestions(
    customerFeedbackId: ID!
    responses: [FeedbackResponse]
  ): [Question]
  submitResponses(
    customerFeedbackId: ID!
    responses: [FeedbackResponse]!
  ): Boolean

  """
  Creates a Loyalty Card for an organization
  """
  createLoyaltyCard(input: LoyaltyCardCreateInput!): LoyaltyCard

  """
  Updates LoyaltyCard based on ID
  """
  updateLoyaltyCard(input: LoyaltyCardUpdateInput!): LoyaltyCard

  """
  Creates Customer Loyalty for a customer
  """
  createCustomerLoyalty(input: CustomerLoyaltyInput!): CustomerLoyaltyOutput

  """
  Create a new Currency. Currency defines the conversion between points and actual tender
  """
  createCurrency(input: CurrencyCreateInput!): Currency

  """
  Updates Currency queriable by code
  """
  updateCurrency(input: CurrencyUpdateInput!): Currency
  issuePoints(input: EarnableLoyaltyTransactionInput): ProcessLoyaltyOutput
  burnPoints(input: EarnableLoyaltyTransactionInput): ProcessLoyaltyOutput
  expireCustomerLoyaltyPoints: Boolean
  blockPoints(
    input: EarnableLoyaltyTransactionInput
  ): EarnableLoyaltyTransactionOutput
  applyBlock(loyaltyReferenceId: String): Boolean
  loyaltyTransactionCompleted(loyaltyReferenceId: ID!): TransactionStatusOutput
  cancelLoyaltyTransaction(
    externalCustomerId: String!
    loyaltyReferenceId: String
    loyaltyType: String
    completeBurn: Boolean
    completeEarn: Boolean
    organizationId: String
  ): CancelLoyaltyTransactionOutput
  createLoyaltyTransactionStatusCodes(
    StatusInput: LoyaltyStatusInput
  ): LoyaltyStatusOutput
  processLoyaltyIssuance(
    externalCustomerId: String
    loyaltyReferenceId: String
    loyaltyType: String
    data: JSON!
  ): ProcessLoyaltyOutput
  processLoyaltyRedemption(
    externalCustomerId: String
    loyaltyReferenceId: String
    loyaltyType: String
    pointsToRedeem: Float
    data: JSON!
  ): ProcessLoyaltyOutput
  createOrUpdateLoyaltyTransaction(
    externalCustomerId: String
    loyaltyReferenceId: String
    loyaltyType: String
    statusCode: String
    data: JSON
  ): LoyaltyTransaction
  processLoyaltyTransaction(
    eventType: String
    loyaltyDate: String
    recordCount: Int
  ): TransactionStatus
  issuePointsWithOrderId(loyaltyReferenceId: String): ProcessLoyaltyOutput
  initiateLoyaltyTransaction(
    eventType: String
    loyaltyDate: String
  ): TransactionStatus

  """
  Creates a new loyalty program
  """
  createLoyaltyProgram(input: CreateLoyaltyProgramInput!): LoyaltyProgram
  updateLoyaltyProgram(input: UpdateLoyaltyProgramInput): LoyaltyProgram
  createCustomerSession(
    input: CreateCustomerSessionInput!
  ): CreateCustomerSessionOutput!
  updateCustomerProfileInSession(
    input: UpdateCustomerProfileInputInSession!
  ): UpdateCustomerProfileOutputInSession!

  """
  Intialize NearX for an organization, used when the organization starts using nearX,
  """
  initializeNearX(
    """
    The organization Id for which we need to enable refinex
    """
    organizationId: ID!
  ): Boolean
}

type Offer {
  createdBy: String
  createdTime: DateTime
  lastModifiedBy: String
  lastModifiedTime: DateTime
  id: ID
  name: String
  description: String
  offerType: OFFER_TYPE
  offerCategory: OFFER_CATEGORY
  reward: JSON
  offerEligibilityRule: Rule
  rewardRedemptionRule: Rule
  isCustomCoupon: Boolean
  coupon: String
  organization: Organization
  state: String
  stateCode: Int
  status: STATUS
}

enum OFFER_CATEGORY {
  AUTO_APPLY
  COUPONS
}

enum OFFER_STATES {
  DRAFT
  NO_STATE
  LIVE
  CLOSED
}

enum OFFER_TYPE {
  PERCENTAGE_DISCOUNT
  FLATX_DISCOUNT
  PERCENTAGE_CASHBACK
  FLATX_CASHBACK
  FREE_ITEMS_FROM_LIST
}

input OfferInput {
  name: String!
  description: String
  offerType: OFFER_TYPE!
  offerCategory: OFFER_CATEGORY!
  reward: JSON
  offerEligibilityRule: ID
  rewardRedemptionRule: ID
  isCustomCoupon: Boolean
  coupon: String
  organizationId: ID
}

type OfferPage {
  data: [Offer]
  paginationInfo: PaginationInfo
}

type Option {
  id: ID
  name: String
  description: String
  optionValues: [OptionValue]
}

input OptionInput {
  name: String!
  description: String
  optionValues: [ValueInput]
}

type OptionValue {
  id: ID
  value: String
  option: Option
}

input OptionValueInput {
  optionId: ID!
  value: String
}

enum ORDER {
  ASC
  DESC
}

type Organization {
  id: ID!
  webhooks(event: String, status: STATUS): [Webhook]
  name: String!
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalOrganizationId: String
  code: String
  status: STATUS!
  phoneNumber: String
  website: String
  extend: JSON
  organizationType: OrganizationTypeEnum
  applications: [Application]
  parent: Organization
  children: [Organization]
  store: Store
  users: [User]
  walkinProducts: [WalkinProduct]
  rules: [Rule]
  workflows: [Workflow]
  actions: [Action]
}

enum OrganizationTypeEnum {
  ORGANIZATION
  STORE
}

input PageOptions {
  page: Int = 1
  pageSize: Int = 10
}

type PaginationInfo {
  totalPages: Int!
  totalItems: Int!
  page: Int!
  perPage: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

input PermissionMap {
  resource: POLICY_RESOURCES
  permission: POLICY_PERMISSIONS
}

type Policy {
  id: ID!
  effect: POLICY_EFFECTS
  resource: POLICY_RESOURCES
  permission: POLICY_PERMISSIONS
  type: POLICY_TYPES
  accessLevel: POLICY_LEVELS
}

enum POLICY_EFFECTS {
  ALLOW
  DENY
}

enum POLICY_LEVELS {
  OWN
  ALL
}

enum POLICY_PERMISSIONS {
  VIEW
  MODIFY
  CREATE
  READ
  UPDATE
  DELETE
  LIST
  SEARCH
  EXECUTE
}

enum POLICY_RESOURCES {
  ORGANIZATION
  USER
  APPLICATION
  STORE
  ROLE
  CATALOG
  CATEGORY
  PRODUCT
  WEBHOOKS
  EVENTS
  PLACES
  CUSTOMER
  CUSTOMER_DEVICE
  FEEDBACK_CATEGORY
  FEEDBACK_FORM
  FEEDBACK_RESPONSE
  FEEDBACK_QUESTION
  FEEDBACK_CHOICE
  APIKEY
  ACTION
  ACTION_DEFNITION
  AUDIENCE
  BUSINESS_RULE
  CAMPAIGN
  COMMUNICATION
  ENTITY_EXTEND
  EVENT
  FILE_SYSTEM
  MEMBER
  METRIC
  METRIC_FILTER
  POLICY
  RULE
  SEGMENT
  SESSION
  WORKFLOW
  REPORT_CONFIG
  REPORTS
  FILE
  CUSTOMER_FEEDBACK
  TAXTYPE
  STOREFORMAT
  REFINEX_CONSOLE
  DOWNLOAD_EVENTS
  DOWNLOAD_CUSTOMERS
  SETTINGS_GLOBAL
  SETTINGS_NEARX
  UPLOAD_PLACES
}

enum POLICY_TYPES {
  UI
  ENTITY
}

input PolicyEditInput {
  id: ID!
  effect: POLICY_EFFECTS
  resource: POLICY_RESOURCES
  permission: POLICY_PERMISSIONS
  accessLevel: POLICY_LEVELS
  type: POLICY_TYPES
}

input PolicyInput {
  effect: POLICY_EFFECTS
  resource: POLICY_RESOURCES
  permission: POLICY_PERMISSIONS
  type: POLICY_TYPES
  accessLevel: POLICY_LEVELS
}

input ProcessEventInput {
  id: ID!
  sourceEventId: String
  sourceEventTime: Date
  sourceName: String
  data: JSON
  metadata: JSON
  eventTypeCode: String!
}

type ProcessLoyaltyOutput {
  id: String
  status: String
  externalCustomerId: String
  loyaltyReferenceId: String
  earnedPoints: Float
  earnedAmount: String
  burnedPoints: Float
  burnedAmount: String
  loyaltyCardCode: String
  earnedPointsExpiryValue: String
  earnedPointsExpiryUnit: String
  blockedPoints: Float
}

type Product {
  id: ID
  code: String
  name: String
  description: String
  imageUrl: String
  sku: String
  type: ProductTypeEnum
  extend: JSON
  status: STATUS
  organization: Organization
  variants: [ProductVariant]
}

type ProductCategory {
  id: ID
  category: Category
  product: Product
}

input ProductCategoryInput {
  productId: ID!
  categoryId: ID!
}

type CategoryProductOption {
  id: ID
  option: Option
  product: Product
}

input CategoryProductOptionInput {
  optionId: ID!
  productId: ID!
}

input ProductSearchInput {
  categoryId: ID
  organizationId: ID!
}

enum ProductTypeEnum {
  REGULAR
  VARIANT
  FIXED_BUNDLE
  DYNAMIC_BUNDLE
}

type ProductVariant {
  id: ID
  sku: String
  product: Product
  optionValues: [OptionValue]
}

input ProductVariantInput {
  sku: String!
  productId: ID!
}

type ProductVariantValue {
  id: ID
  productVariant: ProductVariant
  optionValue: OptionValue
}

input ProductVariantValueInput {
  productVariantId: ID!
  optionValueId: ID!
}

"""
 Query is used to fetch data from the server
"""
type Query {
  metric(id: ID!, organizationId: ID): Metric
  metrics(
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
    organizationId: ID
    status: STATUS!
  ): MetricPage
  metricFilter(id: ID!, organizationId: ID): MetricFilter
  metricFilters(
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
    status: STATUS!
    organizationId: ID
  ): MetricFilterPage
  executeMetric(
    name: String
    organizationId: ID
    filterValues: JSON
  ): MetricExecutionResult
  executeMetrics(
    names: [String]
    organizationId: ID
    walkinProducts: WALKIN_PRODUCTS!
    filterValues: JSON
  ): MetricExecutionResultPage
  webhookEventType(organizationId: ID!, event: String!): WebhookEvent
  webhookEventTypes(
    organizationId: ID!
    status: STATUS!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): WebhookEventPage
  webhook(organizationId: ID!, id: ID!): Webhook
  webhooks(
    organizationId: ID!
    event: String
    status: STATUS!
    enabled: Boolean
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): WebhookPage
  webhookEventData(
    organizationId: ID!
    webhookId: ID!
    httpStatus: String
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): WebhookEventDataPage
  users(
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
    organizationId: String!
  ): UserPage
  user(id: ID!, organizationId: String!): User
  organizationHierarchies: [JSON]
  organizationHierarchy(rootId: ID!): JSON
  organization(id: ID!): Organization
  organizationRoots: [Organization]
  subOrganizations(
    parentId: ID!
    type: OrganizationTypeEnum
    status: STATUS
  ): [Organization]

  """
  Fetch all the Applications data from the server
  """
  applications: [Application!]!

  """
  Fetch a single Application data for the unique id provided
  """
  application(
    """
    Unique id of the Application which need to be fetched from the Server
    """
    id: ID!
  ): Application
  roles: [Role]
  role(id: ID!): Role
  store(id: ID!): Store
  stores: [Store]
  storeByCode(code: String!): Store
  storeSearch(
    organizationId: ID!
    filterValues: StoreSearchFilters
    pageNumber: Int!
    sort: Sort
  ): StoreSearchOutput
  storeDefnition(organizationId: ID!): StoreDefnition
  eventById(id: ID!): Event
  eventBySourceEventId(sourceEventId: String!, eventTypeId: ID): Event
  eventsByFilters(sourceName: String, eventTypeCode: String): [Event]
  eventSubscriptionsForEventType(eventTypeId: ID!): [EventSubscription]
  eventSubscriptionById(id: ID!): EventSubscription
  eventTypeById(id: ID!): EventType
  eventTypeByCode(code: String!): EventType
  eventTypesForApplication(appId: ID!): [EventType]
  ruleEntity(id: ID!): RuleEntity
  ruleEntities(input: SearchRuleEntityInput): [RuleEntity]
  ruleAttribute(id: ID!): RuleAttribute
  ruleAttributes(input: SearchRuleAttributeInput!): [RuleAttribute]
  rule(id: ID!): Rule
  rules(input: SearchRuleInput): [Rule]
  getSQLFromRule(ruleId: ID!): SQL
  evaluateRule(ruleName: String, data: JSON!, ruleId: ID): RuleEvaluatioResult
  businessRules(input: SearchBusinessRulesInput!): [BusinessRule]
  businessRule(id: ID!): BusinessRule
  businessRuleDetails(
    input: SearchBusinessRuleDetailsInput!
  ): [BusinessRuleDetail]
  businessRuleDetail(id: ID!): BusinessRuleDetail
  businessRuleConfiguration(input: BusinessRuleConfigurationInput!): String!
  workflow(id: ID!): Workflow
  workflowByName(name: String!, organizationId: String!): Workflow
  workflowDiagram(id: ID!): workflowDiagram
  workflows: [Workflow]
  orgWorkflows(orgId: ID!): [Workflow]
  workflowState(id: ID!): WorkflowState
  workflowStates(workflowId: ID!): [WorkflowState]
  workflowProcess(id: ID!): WorkflowProcess
  workflowProcessByName(name: String!, workflowId: String!): Workflow
  workflowProcesses(workflowId: ID!): [WorkflowProcess]
  workflowProcessTransition(id: ID!): WorkflowProcessTransition
  workflowProcessTransitions(
    workflowProcessId: ID!
  ): [WorkflowProcessTransition]
  workflowEntity(id: ID!): WorkflowEntity
  workflowEntityByEntityDetails(
    entityId: String!
    entityType: WORKFLOW_ENTITY_TYPE!
  ): WorkflowEntity
  workflowEntityTransition(id: ID!): WorkflowEntityTransition
  workflowEntityTransitionByEntityId(
    workflowEntityId: ID!
  ): WorkflowEntityTransition
  workflowEntityTransitionHistory(
    workflowEntityId: ID!
  ): [WorkflowEntityTransitionHistory]
  workflowRoute(id: ID!): WorkflowRoute
  workflowRoutes(
    organizationId: ID!
    entityType: WORKFLOW_ENTITY_TYPE!
  ): [WorkflowRoute]
  customer(input: SearchCustomerInput): Customer
  customers: [Customer]
  customerDevice(input: SearchCustomerDeviceInput): CustomerDevice
  customerDefnition(organization_id: ID!): CustomerDefnition
  customerDevicesByCustomerId(customerId: String!): [CustomerDevice]
  customerDevices: [CustomerDevice]
  customerCount: JSON
  customerSearch(
    organizationId: ID!
    filterValues: CustomerSearchFilters
    pageNumber: Int!
    sort: Sort
  ): CustomerSearchOutput
  getSegmentRuleAsText(ruleId: ID): JSON

  """
   Fetches entityNames
  """
  entities: [EXTEND_ENTITIES]

  """
   Fetches all extended entities, specific to organization
  """
  entityExtend(id: ID!): EntityExtend

  """
   Fetches all extended entities, specific to organization
  """
  entityExtendByName(entityName: EXTEND_ENTITIES!): EntityExtend

  """
   Fetches corresponding fields of the extended entities specific to organization
  """
  entityExtendField(id: ID!): EntityExtendField

  """
   Fetches basic fields of an entity
  """
  basicFields(entityName: EXTEND_ENTITIES!): [BasicField]
  actionDefinition(id: ID!, organizationId: ID): ActionDefinition
  actionDefinitions(
    organizationId: ID
    name: String
    type: String
    status: String = "ACTIVE"
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions = { sortBy: "id", sortOrder: ASC }
  ): ActionDefinitionPage
  action(id: ID!, organizationId: ID): Action
  actions(
    organizationId: ID
    actionDefinitionName: String
    status: String = "ACTIVE"
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions = { sortBy: "id", sortOrder: ASC }
  ): ActionPage
  session(id: ID!): Session
  activeSession(customer_identifier: String!, organization_id: ID!): Session
  segment(id: ID!): Segment
  segments(
    name: String
    organization_id: ID!
    application_id: ID
    segmentType: String
    status: STATUS!
  ): [Segment]
  campaign(id: ID!): Campaign
  campaigns(
    organization_id: ID
    application_id: ID
    campaignType: [String]
    status: STATUS!
  ): [Campaign]
  audience(id: ID!): Audience
  audiences(
    organization_id: ID!
    application_id: ID
    campaign_id: ID
    segment_id: ID
    status: STATUS
  ): [Audience]
  campaignControls(
    organization_id: ID!
    campaign_id: ID!
    customer_id: ID
  ): [CampaignControl]
  globalControls(organization_id: ID!, customer_id: ID): [GlobalControl]
  audienceCount(segments: [ID], organizationId: ID!): AudienceCountOutput
  audienceMembers(audience_id: ID!, customer_id: ID): [AudienceMember]

  """
  Outputs totalAudienceCount for a campaign. Executes rule associated to campaign & audiences
  """
  totalAudienceCountForCampaign(campaignId: ID!): AudienceCountOutput
  fileSystem(id: ID!, organizationId: ID): FileSystem
  fileSystems(
    name: String
    accessType: String
    fileSystemType: String
    status: String
    organizationId: ID!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions = { sortBy: "id", sortOrder: ASC }
  ): FileSystemsPage
  file(id: ID!, organizationId: ID): File
  files(
    fileSystemId: ID
    name: String
    status: String
    organizationId: ID!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions = { sortBy: "id", sortOrder: ASC }
  ): FilesPage
  messageTemplate(id: ID!, organization_id: ID!): MessageTemplate
  messageTemplates(
    organization_id: ID!
    messageFormat: MESSAGE_FORMAT
    status: STATUS
  ): [MessageTemplate]
  communication(id: ID!, organization_id: ID!): Communication
  communications(
    entityId: ID
    entityType: COMMUNICATION_ENTITY_TYPE
    organization_id: ID!
    status: STATUS
    campaignId: ID
  ): [Communication]
  communicationLog(communicationLogId: ID!): CommunicationLog
  communicationLogs(communicationId: ID!): [CommunicationLog]
  catalog(id: ID!): Catalog
  catalogs(organizationId: ID!): [Catalog]
  category(id: ID!): Category
  categoryByCode(catalogId: ID!, categoryCode: String!): Category
  categoriesWithChildren(catalogId: ID!, categoryCode: String): Category
  categories(catalogId: ID!, parentCategoryId: ID): [Category]
  optionById(id: ID!): Option
  options: [Option]
  optionValuesByOptionId(optionId: ID!): [OptionValue]
  products(input: ProductSearchInput): [Product]
  productOptionsByProductId(productId: ID!): [CategoryProductOption]
  productVariantsByProductId(productId: ID!): [ProductVariant]
  productVariantValuesByProductVariantId(
    productVariantId: ID!
  ): [ProductVariantValue]
  productCategoriesByCategoryId(categoryId: ID!): [ProductCategory]
  productCategoriesByCategoryCode(categoryCode: String!): [ProductCategory]
  chargeTypes(input: ChargeTypesInput): [Charge]
  chargeType(input: ChargeTypeInput): Charge
  channels: [Channel]
  channel(input: ChannelFilterInput): ChannelPage
  taxType(id: ID!, status: STATUS, organizationId: ID): TaxType
  taxTypes(
    status: STATUS
    organizationId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): TaxTypePage
  storeFormat(id: ID!, status: STATUS, organizationId: ID): StoreFormat
  storeFormats(
    status: STATUS
    organizationId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): StoreFormatPage
  reportConfig(id: ID!, organizationId: ID!): ReportConfig
  reportConfigs(
    organizationId: ID!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): ReportConfigPage
  report(id: ID!, organizationId: ID!): Report
  reports(
    reportConfigId: ID!
    reportDate: Date!
    organizationId: ID!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): ReportPage
  offersForACampaign(
    campaignId: ID!
    organizationId: ID!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): CampaignOfferPage
  campaignsForOffer(
    offerId: ID!
    organizationId: ID!
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): CampaignOfferPage
  customerOffer(id: ID!, organizationId: ID): CustomerOffersOutput
  customerOffers(
    organizationId: ID
    offerId: ID
    customerId: ID
    status: STATUS
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): CustomerOfferPage
  offer(id: ID!, organizationId: ID): Offer
  offers(
    stateCode: Int
    state: OFFER_STATES
    organizationId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): OfferPage
  redemption(id: ID!, organizationId: ID): RedemptionOutput
  redemptions(
    organizationId: ID
    customerId: ID
    campaignId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): [RedemptionOutput]
  getHyperX(organizationId: ID!): [HyperXOutput]
  viewCampaignsForHyperX(
    input: HyperXCampaignInput
    page: Int!
    perPage: Int!
    sort: SortOptions!
  ): ViewHyperXCampaignsOutput
  viewCampaignForHyperX(campaignId: ID!): ViewHyperXCampaignOutput

  """
  Fetch a feedback form by id, feedback form provides the starting point for a questionnaire as well as contains
  settings for a feedback form
  """
  getFeedbackForm(
    """
    Feedback id for which feedback form needs to be fetched
    """
    feedbackFormId: ID!
  ): FeedbackForm

  """
  Fetch all the feedback forms from the database
  This just returns all the feedback forms from the database, eventually it
  should be only returning feedback form for the calling entity's organization
  """
  feedbackForms(filter: FeedbackFormCreateInput): FeedbackFormsResponse

  """
  Fetch a feedback category for the unique id
  A feedback category is used to map a question to a category, think of this as issue tags
  STILL IN DEVELOPMENT
  """
  feedbackCategory(
    """
    Unique id ofFeedback Category
    """
    id: ID!
  ): FeedbackCategory

  """
  Fetch the entire feedback category tree for an organization
  The feedback category is actually a tree, so that we can have parent categories and their childrens
  STILL IN DEVELOPMENT
  """
  feedbackCategoryTree(
    """
    Unique organization id
    """
    organizationId: ID!
  ): FeedbackCategory

  """
  Fetch the Category Sub tree for a Category
  If you want to get all the categories under a feedack category the you can use this api to get the entiry subtree
  STILL IN DEVELOPMENT
  """
  feedbackCategorySubTree(
    """
    Unique Feedback Category id whose sub tree need to be found
    """
    id: ID!
  ): FeedbackCategory

  """
  Fetch all feedback categories from database
  This just returns all the feedback categories as a flat array, please note
  that the feedback categories are actually a tree
  STILL IN DEVELOPMENT
  """
  feedbackCategories: [FeedbackCategory]

  """
  Fetches the customer feedback instance generated for a
  customer, which has the feedback form nested in it
  """
  customerFeedback(
    """
    Unique Customer Feedback id
    """
    id: ID!
  ): CustomerFeedback

  """
  This is a newer api created for instances where the feedback form is sent to unknown customer,
  So we create a new customer based on the customer identifier and then we create a customer feedback,
  so therefore a customer identifier is necessary, if possible provide a phone
  number or external customer id as this, or just send any random unique string
  """
  customerFeedbackForNewCustomer(
    customerIdentifier: String!
    feedbackFormId: ID!
  ): CustomerFeedback

  """
  Fetches a list of  Feedback form  external customer ID,
  You can get all the different customer feedbacks generated for the customer, using this API
  """
  customerFeedbackByExternalCustomerId(
    externalCustomerId: String!
    eventType: String
    organizationId: String
    pageOptions: PageOptions!
    sortOptions: SortOptions
  ): CustomerFeedbackResponse

  """
  Fetches a list of  Feedback form  customer mobile number
  You can get all the different customer feedbacks generated for the customer, using this API
  """
  customerFeedbackByMobileNumber(
    mobileNumber: String!
    eventType: String
    organizationId: String
    pageOptions: PageOptions!
    sortOptions: SortOptions
  ): CustomerFeedbackResponse

  """
  Gets the entire questionnaire as a tree, givent the root question ID is provided,
  used in case entire questionnaire needs to be loaded on the client side
  """
  questionHierarchy(
    """
     Unique id of the question for which the DAG needs to be fetched
    """
    questionId: ID!
  ): [QuestionTreeData]

  """
  Fetch the first question of the feedback form, not being used though as we directly get this data in getFeedbackForm
  """
  questionnaireRoot(
    """
     Unique id of the feedback form
    """
    feedbackFormId: ID!
  ): Question

  """
  Fetch a single question from the server , When you need a single question from the server
  """
  question(
    """
     Unique id of the question
    """
    id: ID!
  ): Question

  """
  Fetch a choice from the server , for when you need to fetch a single choice from the server
  """
  choice(
    """
     Unique id of the choice you want to fetch from server
    """
    id: ID!
  ): Choice

  """
  This returns a list of all the available question types, supported by RefineX
  """
  questionTypes: JSON

  """
  Fetch a response from the database
  This query fetches just a response, a response is connected to the answer choice and the customer feedback
  """
  response(
    """
    Unique id of the response
    """
    id: ID!
  ): Response

  """
  Fetch all responses from the database for a feedback for
  """
  responsesForFeedbackForm(feedbackFormId: ID!): [CustomerFeedback]

  """
  Get all the feedback templates available in the system. This basically fetches
  all the hosted URLs from the feedback_template_url table
  You should have few templated by default, as its part of the seed data. If not
  deploy the feedback form and use the createFeedbackTemplateURL to create the entity.
  """
  feedbackTemplateURLs: [FeedbackTemplateUrl]

  """
  Gets a particular feedback template url from the db
  """
  feedbackTemplateURL(id: ID!): FeedbackTemplateUrl
  feedbackTemplates: [FeedbackForm]
  initFeedbackForm(feedbackFormId: ID!): InitFeedbackFormData

  """
  Get LoyaltyCard by ID
  """
  loyaltyCard: [LoyaltyCard]

  """
  Get LoyaltyCard by Code
  """
  loyaltyCardByCode(loyaltyCardCode: String!): LoyaltyCard
  loyaltyCards(
    organizationId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): LoyaltyCardPage

  """
  Gets CustomerLoyalty object queried by externalCustomerId
  """
  getCustomerLoyaltyByExternalCustomerId(
    input: CustomerLoyaltyInput!
  ): CustomerLoyaltyOutput

  """
  Gets CustomerLoyalty object queried by externalCustomerId
  This API has been built for JFL Implementation
  """
  getCustomerLoyalty(
    storeId: String
    externalCustomerId: String!
  ): CustomerLoyaltyOutput

  """
  Get Currency object by currencyCode
  """
  currencyByCode(currencyCode: String!): Currency
  currencyList(
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): CurrencyPage
  earnBurnPoints(
    input: EarnableLoyaltyTransactionInput
  ): EarnableBurnableLoyaltyTransactionOutput
  loyaltyTransaction(
    externalCustomerId: ID!
    cardCode: String
    organizationId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): LoyaltyTransactionPage
  getCommunicationQuery(
    loyaltyProgramId: ID
    campaignID: ID
    transactionType: String
    customerData: JSON
  ): Communication
  earnableBurnablePoints(
    externalCustomerId: String
    loyaltyType: String
    data: JSON!
  ): EarnableBurnableLoyaltyTransactionOutput
  loyaltyTransactionStatus(loyaltyReferenceId: String): TransactionStatus

  """
  Returns loyalty Program accessed by loyaltyCode
  """
  getLoyaltyProgramsByCode(input: LoyaltyProgramInput!): LoyaltyProgram
  loyaltyPrograms(
    loyaltyCardCode: String!
    organizationId: ID
    pageOptions: PageOptions = { page: 1, pageSize: 10 }
    sortOptions: SortOptions
  ): LoyaltyProgramPage

  """
  Gets LoyaltyLedgerHistory based on externalCustomerId & loyaltyCardCode
  """
  loyaltyLedgerHistory(
    externalCustomerId: ID!
    cardCode: String!
  ): [LoyaltyLedgerOutputType]

  """
  Gets CustomerLedgerHistory
  Built for JFL Implementation
  """
  getCustomerLedger(
    externalCustomerId: String!
    cardCode: String
    dateStart: DateTime
    dateEnd: DateTime
    page: Int
    itemsPerPage: Int
    orderBy: SORTING_DIRECTIONS
  ): LedgerOutput
}

"""
 Skeleton of Question being send to the user
"""
type Question {
  id: ID!
  questionText: String
  type: String
  feedbackCategory: FeedbackCategory
  feedbackForm: FeedbackForm
  choices: [Choice]
  fromChoice: Choice
  rangeMin: Int
  rangeMax: Int
}

enum Question_Type_Enum {
  SINGLE_ANSWER
  MULTIPLE_ANSWER
  RATING_SCALE
  OPINION_SCALE
  RANKING
  DICHOTOMOUS
  TEXT
  IMAGE
  VIDEO
  AUDIO
  NUMERIC
}

"""
 Skeleton of Input being received from user creating questions
"""
input QuestionInput {
  questionText: String!
  type: Question_Type_Enum!
  rangeMin: Int
  rangeMax: Int
}

type QuestionTreeData {
  id: ID!
  questionText: String
  type: String
  feedbackCategory: FeedbackCategory
  feedbackForm: FeedbackForm
  choices: [Choice]
  fromChoice: [Choice]
  rangeMin: Int
  rangeMax: Int
}

input RedeemOfferInput {
  customerId: ID!
  campaignId: ID!
  offerId: ID!
  redeemDateTime: DateTime!
  transactionDateTime: DateTime!
  transactionData: JSON!
  organizationId: ID
}

type RedemptionOutput {
  id: ID
  customer: Customer
  campaign: Campaign
  offer: Offer
  redeemDateTime: DateTime
  transactionDateTime: DateTime
  transactionData: JSON
  organizationId: Organization
}

type RedemptionPage {
  data: [RedemptionOutput]
  paginationInfo: PaginationInfo
}

type RemovedQuestion {
  questionText: String
  type: String
  rangeMin: Int
  rangeMax: Int
}

input RemoveVariableFromMessageTemplateInput {
  organization_id: ID!
  templateId: ID!
  templateVariableId: ID!
}

input RepeatRuleConfiguration {
  frequency: COMMUNICATION_FREQUENCY
  repeatInterval: Int
  endAfter: DateTime
  byWeekDay: [COMMUNICATION_DAYS]
  byMonthDate: Int
  time: String
  noOfOccurances: Int
}

type RepeatRuleConfigurationOutput {
  frequency: COMMUNICATION_FREQUENCY
  repeatInterval: Int
  endAfter: DateTime
  byWeekDay: [COMMUNICATION_DAYS]
  byMonthDate: Int
  time: String
  noOfOccurances: Int
}

type Report {
  id: ID!
  reportConfig: ReportConfig
  organizationId: ID!
  reportDate: Date
  reportFile: File
  status: STATUS
}

type ReportConfig {
  id: ID!
  name: String
  description: String
  organizationId: ID!
  status: STATUS
}

type ReportConfigPage {
  data: [ReportConfig!]
  paginationInfo: PaginationInfo
}

type ReportPage {
  data: [Report!]
  paginationInfo: PaginationInfo
}

enum REQUEST_METHOD {
  POST
  GET
}

type ResetPasswordResponse {
  userId: String
  email: String
  sentLink: Boolean
}

"""
Skeleton of Response send to user
"""
type Response {
  id: ID!
  createdTime: Date!
  questionData: JSON
  responseData: JSON
  customerFeedback: CustomerFeedback
  choicesSelected: [Choice]
}

type ResponseDep {
  id: ID!
  createdTime: Date!
  questionData: JSON
  responseData: JSON
  customerFeedback: CustomerFeedback
  choiceSelected: [Choice]
}

"""
Skeleton of data send to user when a new response submit to database
"""
type ResponseSubmit {
  savedResponses: [ResponseDep]
  nextQuestions: [Question]
}

type Role {
  id: ID!
  name: String
  description: String
  tags: [String]
  policies: [Policy]
  users: [User]
  createdBy: String
  lastModifiedBy: String
  createdTime: String
  lastModifiedTime: String
}

input RoleEditInput {
  id: ID!
  name: String
  description: String
  tags: [String]
}

input RoleInput {
  name: String!
  description: String
  tags: [String]
}

type Rule {
  id: ID!
  name: String
  description: String
  status: STATUS
  type: RULE_TYPE
  ruleConfiguration: JSON
  ruleExpression: JSON
  organization: Organization
}

enum RULE_TYPE {
  SIMPLE
  CUSTOM
}

type RuleAttribute {
  id: ID
  attributeName: String
  description: String
  status: STATUS
  attributeValueType: String
  organization: Organization!
  ruleEntity: RuleEntity!
}

type RuleEntity {
  id: ID
  entityName: String
  entityCode: String
  status: STATUS
  organization: Organization
  ruleAttributes: [RuleAttribute]
}

type RuleEvaluatioResult {
  id: ID
  name: String
  description: String
  status: STATUS
  type: RULE_TYPE
  ruleConfiguration: JSON
  ruleExpression: JSON
  evaluationResult: JSON
  organization: Organization
}

input RuleInputType {
  attributeName: String!
  attributeValue: String!
  expressionType: EXPRESSION_TYPE!
}

type S3Response {
  url: String
  expiry: String
}

input SearchBusinessRuleDetailsInput {
  ruleLevel: BUSINESS_RULE_LEVELS
  ruleLevelId: String
  ruleType: String
  organizationId: String
}

input SearchBusinessRulesInput {
  ruleLevel: BUSINESS_RULE_LEVELS
  ruleType: String
}

input SearchCustomerDeviceInput {
  id: ID
  fcmToken: String
  deviceId: String
  modelNumber: String
  customerId: String
}

input SearchCustomerInput {
  id: ID
  externalCustomerId: String
  organization_id: ID
  customerIdentifier: String
}

input SearchRuleAttributeInput {
  status: STATUS
  organizationId: ID!
  entityName: String
}

input SearchRuleEntityInput {
  status: STATUS
  organizationId: ID!
  entityName: String
}

input SearchRuleInput {
  status: STATUS
  organizationId: ID!
}

type Segment {
  createdBy: String
  lastModifiedBy: String
  createdTime: DateTime
  lastModifiedTime: DateTime
  id: ID!
  name: String
  description: String
  segmentType: String
  organization: Organization
  application: Application
  rule: Rule
  status: STATUS
}

enum SEGMENT_TYPE {
  CUSTOM
}

input SegmentAddInput {
  name: String!
  description: String
  segmentType: SEGMENT_TYPE!
  organization_id: ID!
  application_id: ID!
  rule_id: ID!
  status: STATUS!
}

input SegmentUpdateInput {
  id: ID!
  name: String
  description: String
  segmentType: SEGMENT_TYPE
  rule_id: ID
  status: STATUS
}

input SendMessageInput {
  format: MESSAGE_FORMAT
  to: String!
  messageBody: String!
  messageSubject: String
}

type Session {
  id: ID!
  customer_id: ID!
  organization_id: ID!
  extend: JSON
  status: STATUS
}

input SignedUploadURLInput {
  name: String!
  description: String
  status: STATUS
  organizationId: String!
  fileSystemId: String!
}

type SignedURL {
  s3Response: S3Response
  cloudinaryResponse: JSON
}

enum SLUGTYPE {
  DATE
  TIMESTAMP
  TIME
  SHORT_TEXT
  LONG_TEXT
  NUMBER
  CHOICES
  BOOLEAN
  JSON
}

input Sort {
  attributeName: String
  order: ORDER
}

enum SORTING_DIRECTIONS {
  ASCENDING
  DESCENDING
}

input SortOptions {
  sortBy: String = "id"
  sortOrder: ORDER = ASC
}

type SQL {
  SQL: String
}

input StartSessionInput {
  customer_identifier: String!
  organization_id: ID!
  extend: JSON
}

enum STATUS {
  ACTIVE
  INACTIVE
}

enum statusCodes {
  INITIATED
  PROCESSED
  COMPLETED
  CANCELLED
}

type Store {
  id: ID!
  name: String
  STATUS: STATUS
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalStoreId: String
  code: String
  extend: JSON
  email: String
  wifi: Boolean
  latitude: String
  longitude: String
  adminLevelId: String
  organization: Organization
  storeFormats: [StoreFormat]
  catalog: Catalog
  channels: [Channel]
}

type StoreAdminLevel {
  id: ID
  name: String
  code: String
  parent: StoreAdminLevel
  stores: [Store]
}

type StoreColumn {
  column_slug: String
  column_search_key: String
  column_label: String
  column_type: String
  searchable: Boolean
  extended_column: Boolean
}

type StoreDefnition {
  entityName: String
  searchEntityName: String
  columns: [StoreColumn]
}

input StoreFieldSearch {
  id: ID
  attributeName: String
  attributeValue: String
  expressionType: EXPRESSION_TYPE
}

type StoreFormat {
  id: ID
  name: String
  description: String
  storeFormatCode: String
  status: STATUS
  organization: Organization
  taxTypes: [TaxType]
}

input StoreFormatInput {
  name: String
  description: String
  storeFormatCode: String!
  status: STATUS
  organization: ID
  taxTypeCodes: [String]
}

type StoreFormatPage {
  data: [StoreFormat]
  paginationInfo: PaginationInfo
}

input StoreFormatSearchInput {
  status: STATUS
  organizationId: ID
}

input StoreSearchFilters {
  rules: [StoreFieldSearch]
  combinator: COMBINATOR
}

type StoreSearchOutput {
  data: [JSON]
  total: Int
  page: Int
}

type TaxType {
  id: ID
  name: String
  taxTypeCode: String
  description: String
  status: STATUS
  organization: Organization
}

input TaxTypeInput {
  name: String
  taxTypeCode: String!
  description: String
  status: STATUS
  organization: ID
}

type TaxTypePage {
  data: [TaxType]
  paginationInfo: PaginationInfo
}

input TaxTypeSearchInput {
  status: STATUS
  organizationId: ID
}

enum TEMPLATE_STYLE {
  MUSTACHE
}

input Transaction {
  transactionType: String
  transactionDate: Date
  transactionChannel: String
  totalAmount: Float
  externalStoreId: String
}

type TransactionStatus {
  status: String
  message: String
}

type TransactionStatusOutput {
  loyaltyReferenceId: String
  statusCode: String
}

enum TriggerActionEnum {
  NEARX
  CUSTOM
  WEBHOOK
  REFINEX_SEND_FEEDBACK
}

type TypeDeleteEvent {
  id: ID!
  code: String
  description: String
  status: STATUS
  application: Application
  eventSubscriptions: [EventSubscription]
  events: [Event]
}

type TypeDeleteEventSubscription {
  triggerAction: TriggerActionEnum
  customAction: Action
  eventType: EventType
  sync: Boolean
  status: String
}

enum UnitOfTime {
  year
  month
  week
  day
  hour
  minute
  second
  millisecond
}

input UpdateActionDefinitionInput {
  id: ID!
  name: String
  type: String
  organizationId: ID
  configuration: JSON
  code: String
  inputSchema: JSON
  outputSchema: JSON
  status: String
}

input updateAudienceInput {
  id: ID!
  status: STATUS
}

input updateAudienceMemberInput {
  id: ID!
  status: STATUS
}

input UpdateBusinessRuleDetailInput {
  ruleLevel: BUSINESS_RULE_LEVELS
  ruleLevelId: String
  ruleType: String
  ruleValue: String
  organizationId: String!
}

input UpdateBusinessRuleInput {
  ruleLevel: BUSINESS_RULE_LEVELS
  ruleType: String
  ruleDefaultValue: String
}

input updateCampaignControl {
  id: ID!
  endTime: DateTime
  status: STATUS
}

input updateCampaignOfferInput {
  offerId: ID!
  campaignId: ID!
  organizationId: ID!
}

input UpdateCatalogInput {
  id: ID!
  name: String
  usage: UpdateCatalogUsageInput
}

input UpdateCatalogUsageInput {
  id: ID!
  purpose: String
}

input UpdateCategoryInput {
  id: ID!
  name: String
  description: String
  catalogId: ID
  status: STATUS
  extend: JSON
  code: String
  parentId: ID
  organizationId: String!
}

input UpdateCommunicationInput {
  id: ID!
  entityId: String!
  entityType: COMMUNICATION_ENTITY_TYPE
  isScheduled: Boolean
  firstScheduleDateTime: DateTime
  isRepeatable: Boolean
  lastProcessedDateTime: DateTime
  repeatRuleConfiguration: RepeatRuleConfiguration
  commsChannelName: String
  status: STATUS!
  campaign_id: ID
}

type UpdateCustomer {
  id: ID
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  gender: String
  dateOfBirth: String
  externalCustomerId: String
  customerIdentifier: String
  organization: Organization
  extend: JSON
  onboard_source: String
  customerDevices: [CustomerDevice]
}

input UpdateCustomerDeviceInput {
  id: ID!
  fcmToken: String
  modelNumber: String
  extend: JSON
  deviceId: String
  customerId: String
}

input UpdateCustomerInput {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  gender: GENDER
  dateOfBirth: String
  externalCustomerId: String
  customerIdentifier: String
  extend: JSON
  organization: ID
}

input updateCustomerOffersInput {
  id: ID!
  campaignId: ID
  offerId: ID
  customerId: ID
  coupon: String
  status: STATUS
  organizationId: ID
}

input UpdateCustomerProfileInputInSession {
  id: String!
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  gender: String
  dateOfBirth: String
  extend: JSON
  authToken: String
}

type UpdateCustomerProfileOutputInSession {
  id: String!
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
  gender: String
  dateOfBirth: String
  extend: JSON
}

"""
Skeleton of the data received by the server to update the feedback category
STILL IN DEVELOPMENT
"""
input UpdateFeedbackCategoryInput {
  id: ID!
  title: String
}

input UpdateFileSystemInput {
  id: ID!
  name: String
  description: String
  accessType: ACCESS_TYPE
  fileSystemType: FILE_SYSTEM_TYPE
  configuration: JSON
  enabled: Boolean
  organizationId: ID!
}

input UpdateLoyaltyProgramInput {
  id: String!
  name: String
  loyaltyCode: String!
  loyaltyCardCode: String!
  organizationId: String
  expiryUnit: ExpiryUnit
  expiryValue: Int
  earnRuleConfiguration: JSON
  burnRuleConfiguration: JSON
  expiryRuleConfiguration: JSON
  campaign: CampaingAddInput
}

input UpdateMessageTemplateInput {
  id: ID!
  organization_id: ID
  name: String
  description: String
  templateBodyText: String
  templateSubjectText: String
  templateStyle: TEMPLATE_STYLE
  url: String
  imageUrl: String
  status: STATUS
}

input UpdateMessageTemplateVariableInput {
  id: ID!
  organization_id: ID!
  name: String
  type: VARIABLE_TYPE!
  format: VARIABLE_FORMAT!
  defaultValue: String
  required: Boolean
  status: STATUS
}

input updateOfferInput {
  id: ID!
  name: String
  description: String
  reward: JSON
  offerEligibilityRule: ID
  rewardRedemptionRule: ID
  isCustomCoupon: Boolean
  coupon: String
  status: STATUS
  organizationId: ID
}

input UpdateOptionInput {
  id: ID!
  name: String!
  description: String
}

input UpdateOptionValueInput {
  id: ID!
  optionId: ID!
  value: String
}

input UpdateOrganizationInput {
  id: ID!
  name: String
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalOrganizationId: String
  code: String
  status: STATUS
  phoneNumber: String
  website: String
  extend: JSON
  organizationType: OrganizationTypeEnum
}

type UpdatePasswordResponse {
  updated: Boolean
}

input UpdateProductCategoryInput {
  id: ID!
  productId: ID!
  categoryId: ID!
}

input UpdateProductInput {
  id: ID!
  name: String!
  description: String
  organizationId: ID!
  imageUrl: String
  type: ProductTypeEnum
  sku: String
  status: STATUS
  extend: JSON
}

input UpdateCategoryProductOptionInput {
  id: ID!
  optionId: ID
  productId: ID
}

input UpdateProductVariantInput {
  id: ID!
  sku: String
  productId: ID!
}

input UpdateProductVariantValueInput {
  id: ID!
  productVariantId: ID!
  optionValueId: ID!
}

input UpdateRuleInput {
  name: String
  description: String
  type: RULE_TYPE
  ruleConfiguration: JSON
  ruleExpression: JSON
}

input UpdateStoreAdminLevel {
  id: ID!
  name: String!
  code: String!
  parentId: ID
}

input UpdateStoreInput {
  id: ID!
  name: String
  STATUS: STATUS
  addressLine1: String
  addressLine2: String
  city: String
  state: String
  pinCode: String
  country: String
  externalStoreId: String
  extend: JSON
  code: String
  email: String
  wifi: Boolean
  latitude: String
  longitude: String
  adminLevelId: String
  parentOrganizationId: String!
  storeFormatCode: String
  catalogCode: String
  channelCode: String
}

input UpdateUploadFileInput {
  id: ID!
  name: String
  description: String
  fileSystemId: String
  organizationId: String!
}

input UpdateWorkflowEntityInput {
  id: ID!
  workflowId: ID!
  entityId: ID!
  entityType: WORKFLOW_ENTITY_TYPE
}

input UpdateWorkflowInput {
  id: ID!
  name: String
  description: String
  organizationId: ID
}

input UpdateWorkflowProcessInput {
  id: ID!
  name: String
  description: String
  workflowId: ID
}

input UpdateWorkflowProcessTransitionInput {
  id: ID!
  name: String
  pickupStateId: ID
  dropStateId: ID
  ruleConfig: String
  workflowProcessId: ID
}

input UpdateWorkflowRouteInput {
  id: ID!
  entityType: WORKFLOW_ENTITY_TYPE
  ruleId: ID
  status: STATUS
}

input UpdateWorkflowStateInput {
  id: ID!
  code: Int
  name: String
  description: String
  workflowId: ID
}

scalar Upload

type UploadFileForCreateBulkCustomerResponse {
  rowCount: Int
  createdCount: Int
  failedCount: Int
  createBulkCustomerResponse: CreateBulkCustomerResponse
  segmentResponse: Segment
}

type User {
  id: ID!
  email: String!
  firstName: String
  lastName: String
  extend: JSON
  status: STATUS
  members: [Member]
  organization: Organization
  createdCampaigns: [Campaign]
  roles: [Role]
  permissionMap(types: [POLICY_TYPES]): JSON
}

input UserCreateInput {
  email: String!
  firstName: String
  lastName: String
  password: String!
}

type UserPage {
  data: [User!]
  paginationInfo: PaginationInfo
}

input UserUpdateInput {
  id: ID!
  email: String
  firstName: String
  lastName: String
  extend: JSON
  status: STATUS
}

type ValidationError {
  phoneNumber: String
  errors: [String]
}

enum VALUE_TYPE {
  NUMBER
  STRING
  OBJECT
  BOOLEAN
  ARRAY
}

input ValueInput {
  value: String
}

enum VARIABLE_FORMAT {
  YYYYMMDD
  HHMM
  NO_FORMATING
}

enum VARIABLE_TYPE {
  STRING
  NUMBER
  DATE
}

type ViewHyperXCampaignOutput {
  campaign: Campaign
  audiences: [Audience]
  offers: [Offer]
  communications: [Communication]
}

type ViewHyperXCampaignsOutput {
  data: [CampaignsOutput]
  paginationInfo: PaginationInfo
}

enum WALKIN_PRODUCTS {
  REFINEX
  NEARX
  REWARDX
  HYPERX
}

type WalkinProduct {
  id: ID
  name: String
  description: String
  latest_version: String
  status: STATUS
}

enum walkinProducts {
  REFINEX
  NEARX
  REWARDX
  HYPERX
}

type Webhook {
  id: ID!
  name: String!
  organization: Organization!
  event: String!
  url: String!
  headers: JSON!
  method: String!
  enabled: Boolean!
  status: STATUS
}

input WebhookAddInput {
  organizationId: ID!
  event: String!
  name: String!
  url: String!
  headers: JSON!
  method: REQUEST_METHOD!
}

input WebhookDeleteInput {
  id: ID!
  organizationId: ID!
}

type WebhookEvent {
  id: ID!
  event: String!
  description: String!
  status: STATUS
}

type WebhookEventData {
  id: ID!
  webhook: Webhook
  data: JSON!
  httpStatus: String!
  status: STATUS
}

input WebhookEventDataAddInput {
  webhookId: ID!
  organizationId: ID!
  data: String!
}

input WebhookEventDataDeleteInput {
  id: ID!
  organizationId: ID!
}

type WebhookEventDataPage {
  data: [WebhookEventData!]
  paginationInfo: PaginationInfo
}

input WebhookEventDataUpdateInput {
  id: ID!
  organizationId: ID!
  httpStatus: String
  status: STATUS
  webhookId: ID!
}

type WebhookEventPage {
  data: [WebhookEvent!]
  paginationInfo: PaginationInfo
}

input WebhookEventTypeAddInput {
  event: String!
  description: String!
  organizationId: ID!
}

input WebhookEventTypeDeleteInput {
  id: ID!
  organizationId: ID!
}

input WebhookEventTypeUpdateInput {
  id: ID!
  organizationId: ID!
  description: String
  status: STATUS
}

type WebhookPage {
  data: [Webhook!]
  paginationInfo: PaginationInfo
}

type WebhookTypePage {
  data: [WebhookEvent!]
  paginationInfo: PaginationInfo
}

input WebhookUpdateInput {
  id: ID!
  organizationId: ID!
  url: String
  name: String
  headers: JSON
  method: String
  status: STATUS
  enabled: Boolean
}

type Workflow {
  id: ID!
  name: String!
  description: String!
  organization: Organization
  workflowProcesses: [WorkflowProcess]
}

enum WORKFLOW_ENTITY_TYPE {
  Campaign
  Offer
}

input WorkflowChildrenProcessInput {
  name: String!
  description: String!
  workflowProcessTransitions: [WorkflowChildrenProcessTransitionInput]!
}

input WorkflowChildrenProcessTransitionInput {
  name: String!
  pickupStateName: String!
  dropStateName: String!
  ruleConfig: String!
}

input WorkflowChildrenStateInput {
  name: String!
  description: String!
}

type workflowDiagram {
  id: ID!
  name: String!
  description: String!
  diagram: String!
}

type WorkflowEntity {
  id: ID!
  workflow: Workflow
  entityId: ID!
  entityType: WORKFLOW_ENTITY_TYPE
  currentTransition: WorkflowEntityTransition
  transitionHistory: [WorkflowEntityTransitionHistory]
}

input WorkflowEntityInput {
  workflowId: ID!
  entityId: ID!
  entityType: WORKFLOW_ENTITY_TYPE!
}

type WorkflowEntityTransition {
  id: ID!
  workflowEntityId: ID!
  workflowProcessTransitionId: ID!
  workflowProcessTransition: WorkflowProcessTransition
}

type WorkflowEntityTransitionHistory {
  id: ID!
  workflowEntityId: ID!
  workflowProcessTransitionId: ID!
  workflowProcessTransition: WorkflowProcessTransition
}

input WorkflowEntityTransitionInput {
  workflowEntityId: ID!
  workflowProcessTransitionId: ID!
}

input WorkflowInput {
  name: String!
  description: String!
  organizationId: ID!
}

type WorkflowProcess {
  id: ID!
  name: String!
  description: String!
  workflow: Workflow
  workflowProcessTransitions: [WorkflowProcessTransition]
}

input WorkflowProcessInput {
  name: String!
  description: String!
  workflowId: ID!
}

type WorkflowProcessTransition {
  id: ID!
  name: String!
  pickupState: WorkflowState
  dropState: WorkflowState
  ruleConfig: String
}

input WorkflowProcessTransitionInput {
  name: String!
  pickupStateId: ID!
  dropStateId: ID!
  ruleConfig: String!
  workflowProcessId: ID!
}

type WorkflowRoute {
  id: ID
  entityType: WORKFLOW_ENTITY_TYPE
  organization: Organization
  rule: Rule
  workflow: Workflow
  status: STATUS
}

input WorkflowRouteInput {
  entityType: WORKFLOW_ENTITY_TYPE!
  organizationId: ID!
  ruleId: ID!
  workflowId: ID!
}

type WorkflowState {
  id: ID!
  code: Int!
  name: String!
  description: String!
  workflow: Workflow
}

input WorkflowStateInput {
  name: String!
  code: Int!
  description: String!
  workflowId: ID!
}

input WorkflowWithChildrenInput {
  name: String!
  description: String!
  organizationId: ID!
  workflowProcesses: [WorkflowChildrenProcessInput]!
  workflowStates: [WorkflowChildrenStateInput]!
}
